// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: jon_shared_cmd_heat_camera.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "jon_shared_data_types.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
namespace cmd {
namespace HeatCamera {
class Calibrate;
struct CalibrateDefaultTypeInternal;
extern CalibrateDefaultTypeInternal _Calibrate_default_instance_;
class DisableDDE;
struct DisableDDEDefaultTypeInternal;
extern DisableDDEDefaultTypeInternal _DisableDDE_default_instance_;
class EnableDDE;
struct EnableDDEDefaultTypeInternal;
extern EnableDDEDefaultTypeInternal _EnableDDE_default_instance_;
class FocusIn;
struct FocusInDefaultTypeInternal;
extern FocusInDefaultTypeInternal _FocusIn_default_instance_;
class FocusOut;
struct FocusOutDefaultTypeInternal;
extern FocusOutDefaultTypeInternal _FocusOut_default_instance_;
class FocusStepMinus;
struct FocusStepMinusDefaultTypeInternal;
extern FocusStepMinusDefaultTypeInternal _FocusStepMinus_default_instance_;
class FocusStepPlus;
struct FocusStepPlusDefaultTypeInternal;
extern FocusStepPlusDefaultTypeInternal _FocusStepPlus_default_instance_;
class FocusStop;
struct FocusStopDefaultTypeInternal;
extern FocusStopDefaultTypeInternal _FocusStop_default_instance_;
class GetMeteo;
struct GetMeteoDefaultTypeInternal;
extern GetMeteoDefaultTypeInternal _GetMeteo_default_instance_;
class Halt;
struct HaltDefaultTypeInternal;
extern HaltDefaultTypeInternal _Halt_default_instance_;
class NextFxMode;
struct NextFxModeDefaultTypeInternal;
extern NextFxModeDefaultTypeInternal _NextFxMode_default_instance_;
class NextZoomTablePos;
struct NextZoomTablePosDefaultTypeInternal;
extern NextZoomTablePosDefaultTypeInternal _NextZoomTablePos_default_instance_;
class Photo;
struct PhotoDefaultTypeInternal;
extern PhotoDefaultTypeInternal _Photo_default_instance_;
class PrevFxMode;
struct PrevFxModeDefaultTypeInternal;
extern PrevFxModeDefaultTypeInternal _PrevFxMode_default_instance_;
class PrevZoomTablePos;
struct PrevZoomTablePosDefaultTypeInternal;
extern PrevZoomTablePosDefaultTypeInternal _PrevZoomTablePos_default_instance_;
class RefreshFxMode;
struct RefreshFxModeDefaultTypeInternal;
extern RefreshFxModeDefaultTypeInternal _RefreshFxMode_default_instance_;
class ResetZoom;
struct ResetZoomDefaultTypeInternal;
extern ResetZoomDefaultTypeInternal _ResetZoom_default_instance_;
class Root;
struct RootDefaultTypeInternal;
extern RootDefaultTypeInternal _Root_default_instance_;
class SaveToTable;
struct SaveToTableDefaultTypeInternal;
extern SaveToTableDefaultTypeInternal _SaveToTable_default_instance_;
class SetAGC;
struct SetAGCDefaultTypeInternal;
extern SetAGCDefaultTypeInternal _SetAGC_default_instance_;
class SetAutoFocus;
struct SetAutoFocusDefaultTypeInternal;
extern SetAutoFocusDefaultTypeInternal _SetAutoFocus_default_instance_;
class SetCalibMode;
struct SetCalibModeDefaultTypeInternal;
extern SetCalibModeDefaultTypeInternal _SetCalibMode_default_instance_;
class SetClaheLevel;
struct SetClaheLevelDefaultTypeInternal;
extern SetClaheLevelDefaultTypeInternal _SetClaheLevel_default_instance_;
class SetDDELevel;
struct SetDDELevelDefaultTypeInternal;
extern SetDDELevelDefaultTypeInternal _SetDDELevel_default_instance_;
class SetDigitalZoomLevel;
struct SetDigitalZoomLevelDefaultTypeInternal;
extern SetDigitalZoomLevelDefaultTypeInternal _SetDigitalZoomLevel_default_instance_;
class SetFilters;
struct SetFiltersDefaultTypeInternal;
extern SetFiltersDefaultTypeInternal _SetFilters_default_instance_;
class SetFxMode;
struct SetFxModeDefaultTypeInternal;
extern SetFxModeDefaultTypeInternal _SetFxMode_default_instance_;
class SetValue;
struct SetValueDefaultTypeInternal;
extern SetValueDefaultTypeInternal _SetValue_default_instance_;
class SetZoomTableValue;
struct SetZoomTableValueDefaultTypeInternal;
extern SetZoomTableValueDefaultTypeInternal _SetZoomTableValue_default_instance_;
class ShiftClaheLevel;
struct ShiftClaheLevelDefaultTypeInternal;
extern ShiftClaheLevelDefaultTypeInternal _ShiftClaheLevel_default_instance_;
class ShiftDDE;
struct ShiftDDEDefaultTypeInternal;
extern ShiftDDEDefaultTypeInternal _ShiftDDE_default_instance_;
class Start;
struct StartDefaultTypeInternal;
extern StartDefaultTypeInternal _Start_default_instance_;
class Stop;
struct StopDefaultTypeInternal;
extern StopDefaultTypeInternal _Stop_default_instance_;
class Zoom;
struct ZoomDefaultTypeInternal;
extern ZoomDefaultTypeInternal _Zoom_default_instance_;
class ZoomIn;
struct ZoomInDefaultTypeInternal;
extern ZoomInDefaultTypeInternal _ZoomIn_default_instance_;
class ZoomOut;
struct ZoomOutDefaultTypeInternal;
extern ZoomOutDefaultTypeInternal _ZoomOut_default_instance_;
class ZoomStop;
struct ZoomStopDefaultTypeInternal;
extern ZoomStopDefaultTypeInternal _ZoomStop_default_instance_;
}  // namespace HeatCamera
}  // namespace cmd
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace cmd {
namespace HeatCamera {

// ===================================================================


// -------------------------------------------------------------------

class ZoomStop final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.ZoomStop) */ {
 public:
  inline ZoomStop() : ZoomStop(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ZoomStop(::google::protobuf::internal::ConstantInitialized);

  inline ZoomStop(const ZoomStop& from)
      : ZoomStop(nullptr, from) {}
  ZoomStop(ZoomStop&& from) noexcept
    : ZoomStop() {
    *this = ::std::move(from);
  }

  inline ZoomStop& operator=(const ZoomStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZoomStop& operator=(ZoomStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZoomStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZoomStop* internal_default_instance() {
    return reinterpret_cast<const ZoomStop*>(
               &_ZoomStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(ZoomStop& a, ZoomStop& b) {
    a.Swap(&b);
  }
  inline void Swap(ZoomStop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZoomStop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ZoomStop* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ZoomStop>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ZoomStop& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ZoomStop& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.ZoomStop";
  }
  protected:
  explicit ZoomStop(::google::protobuf::Arena* arena);
  ZoomStop(::google::protobuf::Arena* arena, const ZoomStop& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.ZoomStop)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class ZoomOut final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.ZoomOut) */ {
 public:
  inline ZoomOut() : ZoomOut(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ZoomOut(::google::protobuf::internal::ConstantInitialized);

  inline ZoomOut(const ZoomOut& from)
      : ZoomOut(nullptr, from) {}
  ZoomOut(ZoomOut&& from) noexcept
    : ZoomOut() {
    *this = ::std::move(from);
  }

  inline ZoomOut& operator=(const ZoomOut& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZoomOut& operator=(ZoomOut&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZoomOut& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZoomOut* internal_default_instance() {
    return reinterpret_cast<const ZoomOut*>(
               &_ZoomOut_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(ZoomOut& a, ZoomOut& b) {
    a.Swap(&b);
  }
  inline void Swap(ZoomOut* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZoomOut* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ZoomOut* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ZoomOut>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ZoomOut& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ZoomOut& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.ZoomOut";
  }
  protected:
  explicit ZoomOut(::google::protobuf::Arena* arena);
  ZoomOut(::google::protobuf::Arena* arena, const ZoomOut& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.ZoomOut)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class ZoomIn final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.ZoomIn) */ {
 public:
  inline ZoomIn() : ZoomIn(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ZoomIn(::google::protobuf::internal::ConstantInitialized);

  inline ZoomIn(const ZoomIn& from)
      : ZoomIn(nullptr, from) {}
  ZoomIn(ZoomIn&& from) noexcept
    : ZoomIn() {
    *this = ::std::move(from);
  }

  inline ZoomIn& operator=(const ZoomIn& from) {
    CopyFrom(from);
    return *this;
  }
  inline ZoomIn& operator=(ZoomIn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ZoomIn& default_instance() {
    return *internal_default_instance();
  }
  static inline const ZoomIn* internal_default_instance() {
    return reinterpret_cast<const ZoomIn*>(
               &_ZoomIn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ZoomIn& a, ZoomIn& b) {
    a.Swap(&b);
  }
  inline void Swap(ZoomIn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ZoomIn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ZoomIn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ZoomIn>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ZoomIn& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ZoomIn& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.ZoomIn";
  }
  protected:
  explicit ZoomIn(::google::protobuf::Arena* arena);
  ZoomIn(::google::protobuf::Arena* arena, const ZoomIn& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.ZoomIn)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class Stop final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.Stop) */ {
 public:
  inline Stop() : Stop(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Stop(::google::protobuf::internal::ConstantInitialized);

  inline Stop(const Stop& from)
      : Stop(nullptr, from) {}
  Stop(Stop&& from) noexcept
    : Stop() {
    *this = ::std::move(from);
  }

  inline Stop& operator=(const Stop& from) {
    CopyFrom(from);
    return *this;
  }
  inline Stop& operator=(Stop&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Stop& default_instance() {
    return *internal_default_instance();
  }
  static inline const Stop* internal_default_instance() {
    return reinterpret_cast<const Stop*>(
               &_Stop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(Stop& a, Stop& b) {
    a.Swap(&b);
  }
  inline void Swap(Stop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Stop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Stop* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Stop>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Stop& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Stop& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.Stop";
  }
  protected:
  explicit Stop(::google::protobuf::Arena* arena);
  Stop(::google::protobuf::Arena* arena, const Stop& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.Stop)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class Start final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.Start) */ {
 public:
  inline Start() : Start(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Start(::google::protobuf::internal::ConstantInitialized);

  inline Start(const Start& from)
      : Start(nullptr, from) {}
  Start(Start&& from) noexcept
    : Start() {
    *this = ::std::move(from);
  }

  inline Start& operator=(const Start& from) {
    CopyFrom(from);
    return *this;
  }
  inline Start& operator=(Start&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Start& default_instance() {
    return *internal_default_instance();
  }
  static inline const Start* internal_default_instance() {
    return reinterpret_cast<const Start*>(
               &_Start_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Start& a, Start& b) {
    a.Swap(&b);
  }
  inline void Swap(Start* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Start* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Start* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Start>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Start& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Start& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.Start";
  }
  protected:
  explicit Start(::google::protobuf::Arena* arena);
  Start(::google::protobuf::Arena* arena, const Start& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.Start)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class ShiftDDE final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.ShiftDDE) */ {
 public:
  inline ShiftDDE() : ShiftDDE(nullptr) {}
  ~ShiftDDE() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ShiftDDE(::google::protobuf::internal::ConstantInitialized);

  inline ShiftDDE(const ShiftDDE& from)
      : ShiftDDE(nullptr, from) {}
  ShiftDDE(ShiftDDE&& from) noexcept
    : ShiftDDE() {
    *this = ::std::move(from);
  }

  inline ShiftDDE& operator=(const ShiftDDE& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShiftDDE& operator=(ShiftDDE&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShiftDDE& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShiftDDE* internal_default_instance() {
    return reinterpret_cast<const ShiftDDE*>(
               &_ShiftDDE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(ShiftDDE& a, ShiftDDE& b) {
    a.Swap(&b);
  }
  inline void Swap(ShiftDDE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShiftDDE* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShiftDDE* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShiftDDE>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ShiftDDE& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ShiftDDE& from) {
    ShiftDDE::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ShiftDDE* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.ShiftDDE";
  }
  protected:
  explicit ShiftDDE(::google::protobuf::Arena* arena);
  ShiftDDE(::google::protobuf::Arena* arena, const ShiftDDE& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // int32 value = 1;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.ShiftDDE)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class ShiftClaheLevel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.ShiftClaheLevel) */ {
 public:
  inline ShiftClaheLevel() : ShiftClaheLevel(nullptr) {}
  ~ShiftClaheLevel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ShiftClaheLevel(::google::protobuf::internal::ConstantInitialized);

  inline ShiftClaheLevel(const ShiftClaheLevel& from)
      : ShiftClaheLevel(nullptr, from) {}
  ShiftClaheLevel(ShiftClaheLevel&& from) noexcept
    : ShiftClaheLevel() {
    *this = ::std::move(from);
  }

  inline ShiftClaheLevel& operator=(const ShiftClaheLevel& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShiftClaheLevel& operator=(ShiftClaheLevel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShiftClaheLevel& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShiftClaheLevel* internal_default_instance() {
    return reinterpret_cast<const ShiftClaheLevel*>(
               &_ShiftClaheLevel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ShiftClaheLevel& a, ShiftClaheLevel& b) {
    a.Swap(&b);
  }
  inline void Swap(ShiftClaheLevel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShiftClaheLevel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShiftClaheLevel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShiftClaheLevel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const ShiftClaheLevel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const ShiftClaheLevel& from) {
    ShiftClaheLevel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(ShiftClaheLevel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.ShiftClaheLevel";
  }
  protected:
  explicit ShiftClaheLevel(::google::protobuf::Arena* arena);
  ShiftClaheLevel(::google::protobuf::Arena* arena, const ShiftClaheLevel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // float value = 1;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.ShiftClaheLevel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class SetZoomTableValue final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.SetZoomTableValue) */ {
 public:
  inline SetZoomTableValue() : SetZoomTableValue(nullptr) {}
  ~SetZoomTableValue() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetZoomTableValue(::google::protobuf::internal::ConstantInitialized);

  inline SetZoomTableValue(const SetZoomTableValue& from)
      : SetZoomTableValue(nullptr, from) {}
  SetZoomTableValue(SetZoomTableValue&& from) noexcept
    : SetZoomTableValue() {
    *this = ::std::move(from);
  }

  inline SetZoomTableValue& operator=(const SetZoomTableValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetZoomTableValue& operator=(SetZoomTableValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetZoomTableValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetZoomTableValue* internal_default_instance() {
    return reinterpret_cast<const SetZoomTableValue*>(
               &_SetZoomTableValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(SetZoomTableValue& a, SetZoomTableValue& b) {
    a.Swap(&b);
  }
  inline void Swap(SetZoomTableValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetZoomTableValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetZoomTableValue* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetZoomTableValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetZoomTableValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SetZoomTableValue& from) {
    SetZoomTableValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SetZoomTableValue* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.SetZoomTableValue";
  }
  protected:
  explicit SetZoomTableValue(::google::protobuf::Arena* arena);
  SetZoomTableValue(::google::protobuf::Arena* arena, const SetZoomTableValue& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // int32 value = 1;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.SetZoomTableValue)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class SetValue final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.SetValue) */ {
 public:
  inline SetValue() : SetValue(nullptr) {}
  ~SetValue() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetValue(::google::protobuf::internal::ConstantInitialized);

  inline SetValue(const SetValue& from)
      : SetValue(nullptr, from) {}
  SetValue(SetValue&& from) noexcept
    : SetValue() {
    *this = ::std::move(from);
  }

  inline SetValue& operator=(const SetValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetValue& operator=(SetValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetValue* internal_default_instance() {
    return reinterpret_cast<const SetValue*>(
               &_SetValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SetValue& a, SetValue& b) {
    a.Swap(&b);
  }
  inline void Swap(SetValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetValue* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetValue* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetValue>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetValue& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SetValue& from) {
    SetValue::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SetValue* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.SetValue";
  }
  protected:
  explicit SetValue(::google::protobuf::Arena* arena);
  SetValue(::google::protobuf::Arena* arena, const SetValue& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // float value = 1;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.SetValue)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class SetFxMode final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.SetFxMode) */ {
 public:
  inline SetFxMode() : SetFxMode(nullptr) {}
  ~SetFxMode() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetFxMode(::google::protobuf::internal::ConstantInitialized);

  inline SetFxMode(const SetFxMode& from)
      : SetFxMode(nullptr, from) {}
  SetFxMode(SetFxMode&& from) noexcept
    : SetFxMode() {
    *this = ::std::move(from);
  }

  inline SetFxMode& operator=(const SetFxMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFxMode& operator=(SetFxMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetFxMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetFxMode* internal_default_instance() {
    return reinterpret_cast<const SetFxMode*>(
               &_SetFxMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SetFxMode& a, SetFxMode& b) {
    a.Swap(&b);
  }
  inline void Swap(SetFxMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetFxMode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetFxMode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetFxMode>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetFxMode& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SetFxMode& from) {
    SetFxMode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SetFxMode* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.SetFxMode";
  }
  protected:
  explicit SetFxMode(::google::protobuf::Arena* arena);
  SetFxMode(::google::protobuf::Arena* arena, const SetFxMode& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
  };
  // .ser.JonGuiDataFxModeHeat mode = 1;
  void clear_mode() ;
  ::ser::JonGuiDataFxModeHeat mode() const;
  void set_mode(::ser::JonGuiDataFxModeHeat value);

  private:
  ::ser::JonGuiDataFxModeHeat _internal_mode() const;
  void _internal_set_mode(::ser::JonGuiDataFxModeHeat value);

  public:
  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.SetFxMode)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int mode_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class SetFilters final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.SetFilters) */ {
 public:
  inline SetFilters() : SetFilters(nullptr) {}
  ~SetFilters() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetFilters(::google::protobuf::internal::ConstantInitialized);

  inline SetFilters(const SetFilters& from)
      : SetFilters(nullptr, from) {}
  SetFilters(SetFilters&& from) noexcept
    : SetFilters() {
    *this = ::std::move(from);
  }

  inline SetFilters& operator=(const SetFilters& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetFilters& operator=(SetFilters&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetFilters& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetFilters* internal_default_instance() {
    return reinterpret_cast<const SetFilters*>(
               &_SetFilters_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(SetFilters& a, SetFilters& b) {
    a.Swap(&b);
  }
  inline void Swap(SetFilters* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetFilters* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetFilters* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetFilters>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetFilters& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SetFilters& from) {
    SetFilters::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SetFilters* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.SetFilters";
  }
  protected:
  explicit SetFilters(::google::protobuf::Arena* arena);
  SetFilters(::google::protobuf::Arena* arena, const SetFilters& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .ser.JonGuiDataVideoChannelHeatFilters value = 1;
  void clear_value() ;
  ::ser::JonGuiDataVideoChannelHeatFilters value() const;
  void set_value(::ser::JonGuiDataVideoChannelHeatFilters value);

  private:
  ::ser::JonGuiDataVideoChannelHeatFilters _internal_value() const;
  void _internal_set_value(::ser::JonGuiDataVideoChannelHeatFilters value);

  public:
  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.SetFilters)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class SetDigitalZoomLevel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.SetDigitalZoomLevel) */ {
 public:
  inline SetDigitalZoomLevel() : SetDigitalZoomLevel(nullptr) {}
  ~SetDigitalZoomLevel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetDigitalZoomLevel(::google::protobuf::internal::ConstantInitialized);

  inline SetDigitalZoomLevel(const SetDigitalZoomLevel& from)
      : SetDigitalZoomLevel(nullptr, from) {}
  SetDigitalZoomLevel(SetDigitalZoomLevel&& from) noexcept
    : SetDigitalZoomLevel() {
    *this = ::std::move(from);
  }

  inline SetDigitalZoomLevel& operator=(const SetDigitalZoomLevel& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetDigitalZoomLevel& operator=(SetDigitalZoomLevel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetDigitalZoomLevel& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetDigitalZoomLevel* internal_default_instance() {
    return reinterpret_cast<const SetDigitalZoomLevel*>(
               &_SetDigitalZoomLevel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(SetDigitalZoomLevel& a, SetDigitalZoomLevel& b) {
    a.Swap(&b);
  }
  inline void Swap(SetDigitalZoomLevel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetDigitalZoomLevel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetDigitalZoomLevel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetDigitalZoomLevel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetDigitalZoomLevel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SetDigitalZoomLevel& from) {
    SetDigitalZoomLevel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SetDigitalZoomLevel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.SetDigitalZoomLevel";
  }
  protected:
  explicit SetDigitalZoomLevel(::google::protobuf::Arena* arena);
  SetDigitalZoomLevel(::google::protobuf::Arena* arena, const SetDigitalZoomLevel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // float value = 1;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.SetDigitalZoomLevel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class SetDDELevel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.SetDDELevel) */ {
 public:
  inline SetDDELevel() : SetDDELevel(nullptr) {}
  ~SetDDELevel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetDDELevel(::google::protobuf::internal::ConstantInitialized);

  inline SetDDELevel(const SetDDELevel& from)
      : SetDDELevel(nullptr, from) {}
  SetDDELevel(SetDDELevel&& from) noexcept
    : SetDDELevel() {
    *this = ::std::move(from);
  }

  inline SetDDELevel& operator=(const SetDDELevel& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetDDELevel& operator=(SetDDELevel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetDDELevel& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetDDELevel* internal_default_instance() {
    return reinterpret_cast<const SetDDELevel*>(
               &_SetDDELevel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(SetDDELevel& a, SetDDELevel& b) {
    a.Swap(&b);
  }
  inline void Swap(SetDDELevel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetDDELevel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetDDELevel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetDDELevel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetDDELevel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SetDDELevel& from) {
    SetDDELevel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SetDDELevel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.SetDDELevel";
  }
  protected:
  explicit SetDDELevel(::google::protobuf::Arena* arena);
  SetDDELevel(::google::protobuf::Arena* arena, const SetDDELevel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // int32 value = 1;
  void clear_value() ;
  ::int32_t value() const;
  void set_value(::int32_t value);

  private:
  ::int32_t _internal_value() const;
  void _internal_set_value(::int32_t value);

  public:
  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.SetDDELevel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::int32_t value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class SetClaheLevel final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.SetClaheLevel) */ {
 public:
  inline SetClaheLevel() : SetClaheLevel(nullptr) {}
  ~SetClaheLevel() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetClaheLevel(::google::protobuf::internal::ConstantInitialized);

  inline SetClaheLevel(const SetClaheLevel& from)
      : SetClaheLevel(nullptr, from) {}
  SetClaheLevel(SetClaheLevel&& from) noexcept
    : SetClaheLevel() {
    *this = ::std::move(from);
  }

  inline SetClaheLevel& operator=(const SetClaheLevel& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetClaheLevel& operator=(SetClaheLevel&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetClaheLevel& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetClaheLevel* internal_default_instance() {
    return reinterpret_cast<const SetClaheLevel*>(
               &_SetClaheLevel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SetClaheLevel& a, SetClaheLevel& b) {
    a.Swap(&b);
  }
  inline void Swap(SetClaheLevel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetClaheLevel* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetClaheLevel* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetClaheLevel>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetClaheLevel& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SetClaheLevel& from) {
    SetClaheLevel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SetClaheLevel* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.SetClaheLevel";
  }
  protected:
  explicit SetClaheLevel(::google::protobuf::Arena* arena);
  SetClaheLevel(::google::protobuf::Arena* arena, const SetClaheLevel& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // float value = 1;
  void clear_value() ;
  float value() const;
  void set_value(float value);

  private:
  float _internal_value() const;
  void _internal_set_value(float value);

  public:
  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.SetClaheLevel)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    float value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class SetCalibMode final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.SetCalibMode) */ {
 public:
  inline SetCalibMode() : SetCalibMode(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetCalibMode(::google::protobuf::internal::ConstantInitialized);

  inline SetCalibMode(const SetCalibMode& from)
      : SetCalibMode(nullptr, from) {}
  SetCalibMode(SetCalibMode&& from) noexcept
    : SetCalibMode() {
    *this = ::std::move(from);
  }

  inline SetCalibMode& operator=(const SetCalibMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetCalibMode& operator=(SetCalibMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetCalibMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetCalibMode* internal_default_instance() {
    return reinterpret_cast<const SetCalibMode*>(
               &_SetCalibMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(SetCalibMode& a, SetCalibMode& b) {
    a.Swap(&b);
  }
  inline void Swap(SetCalibMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetCalibMode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetCalibMode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetCalibMode>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SetCalibMode& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SetCalibMode& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.SetCalibMode";
  }
  protected:
  explicit SetCalibMode(::google::protobuf::Arena* arena);
  SetCalibMode(::google::protobuf::Arena* arena, const SetCalibMode& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.SetCalibMode)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class SetAutoFocus final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.SetAutoFocus) */ {
 public:
  inline SetAutoFocus() : SetAutoFocus(nullptr) {}
  ~SetAutoFocus() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetAutoFocus(::google::protobuf::internal::ConstantInitialized);

  inline SetAutoFocus(const SetAutoFocus& from)
      : SetAutoFocus(nullptr, from) {}
  SetAutoFocus(SetAutoFocus&& from) noexcept
    : SetAutoFocus() {
    *this = ::std::move(from);
  }

  inline SetAutoFocus& operator=(const SetAutoFocus& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAutoFocus& operator=(SetAutoFocus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAutoFocus& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAutoFocus* internal_default_instance() {
    return reinterpret_cast<const SetAutoFocus*>(
               &_SetAutoFocus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(SetAutoFocus& a, SetAutoFocus& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAutoFocus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAutoFocus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAutoFocus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAutoFocus>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetAutoFocus& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SetAutoFocus& from) {
    SetAutoFocus::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SetAutoFocus* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.SetAutoFocus";
  }
  protected:
  explicit SetAutoFocus(::google::protobuf::Arena* arena);
  SetAutoFocus(::google::protobuf::Arena* arena, const SetAutoFocus& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bool value = 1;
  void clear_value() ;
  bool value() const;
  void set_value(bool value);

  private:
  bool _internal_value() const;
  void _internal_set_value(bool value);

  public:
  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.SetAutoFocus)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    bool value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class SetAGC final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.SetAGC) */ {
 public:
  inline SetAGC() : SetAGC(nullptr) {}
  ~SetAGC() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SetAGC(::google::protobuf::internal::ConstantInitialized);

  inline SetAGC(const SetAGC& from)
      : SetAGC(nullptr, from) {}
  SetAGC(SetAGC&& from) noexcept
    : SetAGC() {
    *this = ::std::move(from);
  }

  inline SetAGC& operator=(const SetAGC& from) {
    CopyFrom(from);
    return *this;
  }
  inline SetAGC& operator=(SetAGC&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SetAGC& default_instance() {
    return *internal_default_instance();
  }
  static inline const SetAGC* internal_default_instance() {
    return reinterpret_cast<const SetAGC*>(
               &_SetAGC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(SetAGC& a, SetAGC& b) {
    a.Swap(&b);
  }
  inline void Swap(SetAGC* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SetAGC* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SetAGC* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SetAGC>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SetAGC& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SetAGC& from) {
    SetAGC::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SetAGC* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.SetAGC";
  }
  protected:
  explicit SetAGC(::google::protobuf::Arena* arena);
  SetAGC(::google::protobuf::Arena* arena, const SetAGC& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // .ser.JonGuiDataVideoChannelHeatAGCModes value = 1;
  void clear_value() ;
  ::ser::JonGuiDataVideoChannelHeatAGCModes value() const;
  void set_value(::ser::JonGuiDataVideoChannelHeatAGCModes value);

  private:
  ::ser::JonGuiDataVideoChannelHeatAGCModes _internal_value() const;
  void _internal_set_value(::ser::JonGuiDataVideoChannelHeatAGCModes value);

  public:
  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.SetAGC)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    int value_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class SaveToTable final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.SaveToTable) */ {
 public:
  inline SaveToTable() : SaveToTable(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SaveToTable(::google::protobuf::internal::ConstantInitialized);

  inline SaveToTable(const SaveToTable& from)
      : SaveToTable(nullptr, from) {}
  SaveToTable(SaveToTable&& from) noexcept
    : SaveToTable() {
    *this = ::std::move(from);
  }

  inline SaveToTable& operator=(const SaveToTable& from) {
    CopyFrom(from);
    return *this;
  }
  inline SaveToTable& operator=(SaveToTable&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SaveToTable& default_instance() {
    return *internal_default_instance();
  }
  static inline const SaveToTable* internal_default_instance() {
    return reinterpret_cast<const SaveToTable*>(
               &_SaveToTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(SaveToTable& a, SaveToTable& b) {
    a.Swap(&b);
  }
  inline void Swap(SaveToTable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SaveToTable* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SaveToTable* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SaveToTable>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SaveToTable& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SaveToTable& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.SaveToTable";
  }
  protected:
  explicit SaveToTable(::google::protobuf::Arena* arena);
  SaveToTable(::google::protobuf::Arena* arena, const SaveToTable& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.SaveToTable)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class ResetZoom final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.ResetZoom) */ {
 public:
  inline ResetZoom() : ResetZoom(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR ResetZoom(::google::protobuf::internal::ConstantInitialized);

  inline ResetZoom(const ResetZoom& from)
      : ResetZoom(nullptr, from) {}
  ResetZoom(ResetZoom&& from) noexcept
    : ResetZoom() {
    *this = ::std::move(from);
  }

  inline ResetZoom& operator=(const ResetZoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetZoom& operator=(ResetZoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetZoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetZoom* internal_default_instance() {
    return reinterpret_cast<const ResetZoom*>(
               &_ResetZoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(ResetZoom& a, ResetZoom& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetZoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetZoom* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetZoom* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetZoom>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResetZoom& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResetZoom& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.ResetZoom";
  }
  protected:
  explicit ResetZoom(::google::protobuf::Arena* arena);
  ResetZoom(::google::protobuf::Arena* arena, const ResetZoom& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.ResetZoom)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class RefreshFxMode final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.RefreshFxMode) */ {
 public:
  inline RefreshFxMode() : RefreshFxMode(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR RefreshFxMode(::google::protobuf::internal::ConstantInitialized);

  inline RefreshFxMode(const RefreshFxMode& from)
      : RefreshFxMode(nullptr, from) {}
  RefreshFxMode(RefreshFxMode&& from) noexcept
    : RefreshFxMode() {
    *this = ::std::move(from);
  }

  inline RefreshFxMode& operator=(const RefreshFxMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline RefreshFxMode& operator=(RefreshFxMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RefreshFxMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const RefreshFxMode* internal_default_instance() {
    return reinterpret_cast<const RefreshFxMode*>(
               &_RefreshFxMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(RefreshFxMode& a, RefreshFxMode& b) {
    a.Swap(&b);
  }
  inline void Swap(RefreshFxMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RefreshFxMode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RefreshFxMode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RefreshFxMode>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RefreshFxMode& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RefreshFxMode& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.RefreshFxMode";
  }
  protected:
  explicit RefreshFxMode(::google::protobuf::Arena* arena);
  RefreshFxMode(::google::protobuf::Arena* arena, const RefreshFxMode& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.RefreshFxMode)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class PrevZoomTablePos final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.PrevZoomTablePos) */ {
 public:
  inline PrevZoomTablePos() : PrevZoomTablePos(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PrevZoomTablePos(::google::protobuf::internal::ConstantInitialized);

  inline PrevZoomTablePos(const PrevZoomTablePos& from)
      : PrevZoomTablePos(nullptr, from) {}
  PrevZoomTablePos(PrevZoomTablePos&& from) noexcept
    : PrevZoomTablePos() {
    *this = ::std::move(from);
  }

  inline PrevZoomTablePos& operator=(const PrevZoomTablePos& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrevZoomTablePos& operator=(PrevZoomTablePos&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrevZoomTablePos& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrevZoomTablePos* internal_default_instance() {
    return reinterpret_cast<const PrevZoomTablePos*>(
               &_PrevZoomTablePos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(PrevZoomTablePos& a, PrevZoomTablePos& b) {
    a.Swap(&b);
  }
  inline void Swap(PrevZoomTablePos* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrevZoomTablePos* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrevZoomTablePos* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrevZoomTablePos>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PrevZoomTablePos& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PrevZoomTablePos& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.PrevZoomTablePos";
  }
  protected:
  explicit PrevZoomTablePos(::google::protobuf::Arena* arena);
  PrevZoomTablePos(::google::protobuf::Arena* arena, const PrevZoomTablePos& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.PrevZoomTablePos)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class PrevFxMode final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.PrevFxMode) */ {
 public:
  inline PrevFxMode() : PrevFxMode(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR PrevFxMode(::google::protobuf::internal::ConstantInitialized);

  inline PrevFxMode(const PrevFxMode& from)
      : PrevFxMode(nullptr, from) {}
  PrevFxMode(PrevFxMode&& from) noexcept
    : PrevFxMode() {
    *this = ::std::move(from);
  }

  inline PrevFxMode& operator=(const PrevFxMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrevFxMode& operator=(PrevFxMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrevFxMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrevFxMode* internal_default_instance() {
    return reinterpret_cast<const PrevFxMode*>(
               &_PrevFxMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PrevFxMode& a, PrevFxMode& b) {
    a.Swap(&b);
  }
  inline void Swap(PrevFxMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrevFxMode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrevFxMode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrevFxMode>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PrevFxMode& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PrevFxMode& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.PrevFxMode";
  }
  protected:
  explicit PrevFxMode(::google::protobuf::Arena* arena);
  PrevFxMode(::google::protobuf::Arena* arena, const PrevFxMode& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.PrevFxMode)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class Photo final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.Photo) */ {
 public:
  inline Photo() : Photo(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Photo(::google::protobuf::internal::ConstantInitialized);

  inline Photo(const Photo& from)
      : Photo(nullptr, from) {}
  Photo(Photo&& from) noexcept
    : Photo() {
    *this = ::std::move(from);
  }

  inline Photo& operator=(const Photo& from) {
    CopyFrom(from);
    return *this;
  }
  inline Photo& operator=(Photo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Photo& default_instance() {
    return *internal_default_instance();
  }
  static inline const Photo* internal_default_instance() {
    return reinterpret_cast<const Photo*>(
               &_Photo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(Photo& a, Photo& b) {
    a.Swap(&b);
  }
  inline void Swap(Photo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Photo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Photo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Photo>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Photo& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Photo& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.Photo";
  }
  protected:
  explicit Photo(::google::protobuf::Arena* arena);
  Photo(::google::protobuf::Arena* arena, const Photo& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.Photo)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class NextZoomTablePos final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.NextZoomTablePos) */ {
 public:
  inline NextZoomTablePos() : NextZoomTablePos(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NextZoomTablePos(::google::protobuf::internal::ConstantInitialized);

  inline NextZoomTablePos(const NextZoomTablePos& from)
      : NextZoomTablePos(nullptr, from) {}
  NextZoomTablePos(NextZoomTablePos&& from) noexcept
    : NextZoomTablePos() {
    *this = ::std::move(from);
  }

  inline NextZoomTablePos& operator=(const NextZoomTablePos& from) {
    CopyFrom(from);
    return *this;
  }
  inline NextZoomTablePos& operator=(NextZoomTablePos&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NextZoomTablePos& default_instance() {
    return *internal_default_instance();
  }
  static inline const NextZoomTablePos* internal_default_instance() {
    return reinterpret_cast<const NextZoomTablePos*>(
               &_NextZoomTablePos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(NextZoomTablePos& a, NextZoomTablePos& b) {
    a.Swap(&b);
  }
  inline void Swap(NextZoomTablePos* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NextZoomTablePos* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NextZoomTablePos* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NextZoomTablePos>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NextZoomTablePos& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NextZoomTablePos& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.NextZoomTablePos";
  }
  protected:
  explicit NextZoomTablePos(::google::protobuf::Arena* arena);
  NextZoomTablePos(::google::protobuf::Arena* arena, const NextZoomTablePos& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.NextZoomTablePos)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class NextFxMode final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.NextFxMode) */ {
 public:
  inline NextFxMode() : NextFxMode(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR NextFxMode(::google::protobuf::internal::ConstantInitialized);

  inline NextFxMode(const NextFxMode& from)
      : NextFxMode(nullptr, from) {}
  NextFxMode(NextFxMode&& from) noexcept
    : NextFxMode() {
    *this = ::std::move(from);
  }

  inline NextFxMode& operator=(const NextFxMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline NextFxMode& operator=(NextFxMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NextFxMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const NextFxMode* internal_default_instance() {
    return reinterpret_cast<const NextFxMode*>(
               &_NextFxMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(NextFxMode& a, NextFxMode& b) {
    a.Swap(&b);
  }
  inline void Swap(NextFxMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NextFxMode* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NextFxMode* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NextFxMode>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const NextFxMode& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const NextFxMode& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.NextFxMode";
  }
  protected:
  explicit NextFxMode(::google::protobuf::Arena* arena);
  NextFxMode(::google::protobuf::Arena* arena, const NextFxMode& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.NextFxMode)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class Halt final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.Halt) */ {
 public:
  inline Halt() : Halt(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Halt(::google::protobuf::internal::ConstantInitialized);

  inline Halt(const Halt& from)
      : Halt(nullptr, from) {}
  Halt(Halt&& from) noexcept
    : Halt() {
    *this = ::std::move(from);
  }

  inline Halt& operator=(const Halt& from) {
    CopyFrom(from);
    return *this;
  }
  inline Halt& operator=(Halt&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Halt& default_instance() {
    return *internal_default_instance();
  }
  static inline const Halt* internal_default_instance() {
    return reinterpret_cast<const Halt*>(
               &_Halt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(Halt& a, Halt& b) {
    a.Swap(&b);
  }
  inline void Swap(Halt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Halt* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Halt* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Halt>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Halt& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Halt& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.Halt";
  }
  protected:
  explicit Halt(::google::protobuf::Arena* arena);
  Halt(::google::protobuf::Arena* arena, const Halt& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.Halt)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class GetMeteo final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.GetMeteo) */ {
 public:
  inline GetMeteo() : GetMeteo(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR GetMeteo(::google::protobuf::internal::ConstantInitialized);

  inline GetMeteo(const GetMeteo& from)
      : GetMeteo(nullptr, from) {}
  GetMeteo(GetMeteo&& from) noexcept
    : GetMeteo() {
    *this = ::std::move(from);
  }

  inline GetMeteo& operator=(const GetMeteo& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetMeteo& operator=(GetMeteo&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetMeteo& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetMeteo* internal_default_instance() {
    return reinterpret_cast<const GetMeteo*>(
               &_GetMeteo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GetMeteo& a, GetMeteo& b) {
    a.Swap(&b);
  }
  inline void Swap(GetMeteo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetMeteo* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetMeteo* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetMeteo>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const GetMeteo& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const GetMeteo& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.GetMeteo";
  }
  protected:
  explicit GetMeteo(::google::protobuf::Arena* arena);
  GetMeteo(::google::protobuf::Arena* arena, const GetMeteo& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.GetMeteo)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class FocusStop final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.FocusStop) */ {
 public:
  inline FocusStop() : FocusStop(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FocusStop(::google::protobuf::internal::ConstantInitialized);

  inline FocusStop(const FocusStop& from)
      : FocusStop(nullptr, from) {}
  FocusStop(FocusStop&& from) noexcept
    : FocusStop() {
    *this = ::std::move(from);
  }

  inline FocusStop& operator=(const FocusStop& from) {
    CopyFrom(from);
    return *this;
  }
  inline FocusStop& operator=(FocusStop&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FocusStop& default_instance() {
    return *internal_default_instance();
  }
  static inline const FocusStop* internal_default_instance() {
    return reinterpret_cast<const FocusStop*>(
               &_FocusStop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(FocusStop& a, FocusStop& b) {
    a.Swap(&b);
  }
  inline void Swap(FocusStop* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FocusStop* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FocusStop* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FocusStop>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FocusStop& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FocusStop& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.FocusStop";
  }
  protected:
  explicit FocusStop(::google::protobuf::Arena* arena);
  FocusStop(::google::protobuf::Arena* arena, const FocusStop& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.FocusStop)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class FocusStepPlus final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.FocusStepPlus) */ {
 public:
  inline FocusStepPlus() : FocusStepPlus(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FocusStepPlus(::google::protobuf::internal::ConstantInitialized);

  inline FocusStepPlus(const FocusStepPlus& from)
      : FocusStepPlus(nullptr, from) {}
  FocusStepPlus(FocusStepPlus&& from) noexcept
    : FocusStepPlus() {
    *this = ::std::move(from);
  }

  inline FocusStepPlus& operator=(const FocusStepPlus& from) {
    CopyFrom(from);
    return *this;
  }
  inline FocusStepPlus& operator=(FocusStepPlus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FocusStepPlus& default_instance() {
    return *internal_default_instance();
  }
  static inline const FocusStepPlus* internal_default_instance() {
    return reinterpret_cast<const FocusStepPlus*>(
               &_FocusStepPlus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(FocusStepPlus& a, FocusStepPlus& b) {
    a.Swap(&b);
  }
  inline void Swap(FocusStepPlus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FocusStepPlus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FocusStepPlus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FocusStepPlus>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FocusStepPlus& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FocusStepPlus& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.FocusStepPlus";
  }
  protected:
  explicit FocusStepPlus(::google::protobuf::Arena* arena);
  FocusStepPlus(::google::protobuf::Arena* arena, const FocusStepPlus& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.FocusStepPlus)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class FocusStepMinus final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.FocusStepMinus) */ {
 public:
  inline FocusStepMinus() : FocusStepMinus(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FocusStepMinus(::google::protobuf::internal::ConstantInitialized);

  inline FocusStepMinus(const FocusStepMinus& from)
      : FocusStepMinus(nullptr, from) {}
  FocusStepMinus(FocusStepMinus&& from) noexcept
    : FocusStepMinus() {
    *this = ::std::move(from);
  }

  inline FocusStepMinus& operator=(const FocusStepMinus& from) {
    CopyFrom(from);
    return *this;
  }
  inline FocusStepMinus& operator=(FocusStepMinus&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FocusStepMinus& default_instance() {
    return *internal_default_instance();
  }
  static inline const FocusStepMinus* internal_default_instance() {
    return reinterpret_cast<const FocusStepMinus*>(
               &_FocusStepMinus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(FocusStepMinus& a, FocusStepMinus& b) {
    a.Swap(&b);
  }
  inline void Swap(FocusStepMinus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FocusStepMinus* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FocusStepMinus* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FocusStepMinus>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FocusStepMinus& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FocusStepMinus& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.FocusStepMinus";
  }
  protected:
  explicit FocusStepMinus(::google::protobuf::Arena* arena);
  FocusStepMinus(::google::protobuf::Arena* arena, const FocusStepMinus& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.FocusStepMinus)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class FocusOut final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.FocusOut) */ {
 public:
  inline FocusOut() : FocusOut(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FocusOut(::google::protobuf::internal::ConstantInitialized);

  inline FocusOut(const FocusOut& from)
      : FocusOut(nullptr, from) {}
  FocusOut(FocusOut&& from) noexcept
    : FocusOut() {
    *this = ::std::move(from);
  }

  inline FocusOut& operator=(const FocusOut& from) {
    CopyFrom(from);
    return *this;
  }
  inline FocusOut& operator=(FocusOut&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FocusOut& default_instance() {
    return *internal_default_instance();
  }
  static inline const FocusOut* internal_default_instance() {
    return reinterpret_cast<const FocusOut*>(
               &_FocusOut_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(FocusOut& a, FocusOut& b) {
    a.Swap(&b);
  }
  inline void Swap(FocusOut* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FocusOut* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FocusOut* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FocusOut>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FocusOut& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FocusOut& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.FocusOut";
  }
  protected:
  explicit FocusOut(::google::protobuf::Arena* arena);
  FocusOut(::google::protobuf::Arena* arena, const FocusOut& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.FocusOut)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class FocusIn final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.FocusIn) */ {
 public:
  inline FocusIn() : FocusIn(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR FocusIn(::google::protobuf::internal::ConstantInitialized);

  inline FocusIn(const FocusIn& from)
      : FocusIn(nullptr, from) {}
  FocusIn(FocusIn&& from) noexcept
    : FocusIn() {
    *this = ::std::move(from);
  }

  inline FocusIn& operator=(const FocusIn& from) {
    CopyFrom(from);
    return *this;
  }
  inline FocusIn& operator=(FocusIn&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FocusIn& default_instance() {
    return *internal_default_instance();
  }
  static inline const FocusIn* internal_default_instance() {
    return reinterpret_cast<const FocusIn*>(
               &_FocusIn_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(FocusIn& a, FocusIn& b) {
    a.Swap(&b);
  }
  inline void Swap(FocusIn* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FocusIn* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FocusIn* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FocusIn>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const FocusIn& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const FocusIn& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.FocusIn";
  }
  protected:
  explicit FocusIn(::google::protobuf::Arena* arena);
  FocusIn(::google::protobuf::Arena* arena, const FocusIn& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.FocusIn)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class EnableDDE final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.EnableDDE) */ {
 public:
  inline EnableDDE() : EnableDDE(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR EnableDDE(::google::protobuf::internal::ConstantInitialized);

  inline EnableDDE(const EnableDDE& from)
      : EnableDDE(nullptr, from) {}
  EnableDDE(EnableDDE&& from) noexcept
    : EnableDDE() {
    *this = ::std::move(from);
  }

  inline EnableDDE& operator=(const EnableDDE& from) {
    CopyFrom(from);
    return *this;
  }
  inline EnableDDE& operator=(EnableDDE&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EnableDDE& default_instance() {
    return *internal_default_instance();
  }
  static inline const EnableDDE* internal_default_instance() {
    return reinterpret_cast<const EnableDDE*>(
               &_EnableDDE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(EnableDDE& a, EnableDDE& b) {
    a.Swap(&b);
  }
  inline void Swap(EnableDDE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EnableDDE* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EnableDDE* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EnableDDE>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const EnableDDE& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const EnableDDE& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.EnableDDE";
  }
  protected:
  explicit EnableDDE(::google::protobuf::Arena* arena);
  EnableDDE(::google::protobuf::Arena* arena, const EnableDDE& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.EnableDDE)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class DisableDDE final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.DisableDDE) */ {
 public:
  inline DisableDDE() : DisableDDE(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR DisableDDE(::google::protobuf::internal::ConstantInitialized);

  inline DisableDDE(const DisableDDE& from)
      : DisableDDE(nullptr, from) {}
  DisableDDE(DisableDDE&& from) noexcept
    : DisableDDE() {
    *this = ::std::move(from);
  }

  inline DisableDDE& operator=(const DisableDDE& from) {
    CopyFrom(from);
    return *this;
  }
  inline DisableDDE& operator=(DisableDDE&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DisableDDE& default_instance() {
    return *internal_default_instance();
  }
  static inline const DisableDDE* internal_default_instance() {
    return reinterpret_cast<const DisableDDE*>(
               &_DisableDDE_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(DisableDDE& a, DisableDDE& b) {
    a.Swap(&b);
  }
  inline void Swap(DisableDDE* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DisableDDE* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DisableDDE* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DisableDDE>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DisableDDE& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DisableDDE& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.DisableDDE";
  }
  protected:
  explicit DisableDDE(::google::protobuf::Arena* arena);
  DisableDDE(::google::protobuf::Arena* arena, const DisableDDE& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.DisableDDE)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class Calibrate final :
    public ::google::protobuf::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.Calibrate) */ {
 public:
  inline Calibrate() : Calibrate(nullptr) {}
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Calibrate(::google::protobuf::internal::ConstantInitialized);

  inline Calibrate(const Calibrate& from)
      : Calibrate(nullptr, from) {}
  Calibrate(Calibrate&& from) noexcept
    : Calibrate() {
    *this = ::std::move(from);
  }

  inline Calibrate& operator=(const Calibrate& from) {
    CopyFrom(from);
    return *this;
  }
  inline Calibrate& operator=(Calibrate&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Calibrate& default_instance() {
    return *internal_default_instance();
  }
  static inline const Calibrate* internal_default_instance() {
    return reinterpret_cast<const Calibrate*>(
               &_Calibrate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(Calibrate& a, Calibrate& b) {
    a.Swap(&b);
  }
  inline void Swap(Calibrate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Calibrate* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Calibrate* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Calibrate>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Calibrate& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Calibrate& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.Calibrate";
  }
  protected:
  explicit Calibrate(::google::protobuf::Arena* arena);
  Calibrate(::google::protobuf::Arena* arena, const Calibrate& from);
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.Calibrate)
 private:
  class _Internal;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class Zoom final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.Zoom) */ {
 public:
  inline Zoom() : Zoom(nullptr) {}
  ~Zoom() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Zoom(::google::protobuf::internal::ConstantInitialized);

  inline Zoom(const Zoom& from)
      : Zoom(nullptr, from) {}
  Zoom(Zoom&& from) noexcept
    : Zoom() {
    *this = ::std::move(from);
  }

  inline Zoom& operator=(const Zoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline Zoom& operator=(Zoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Zoom& default_instance() {
    return *internal_default_instance();
  }
  enum CmdCase {
    kSetZoomTableValue = 1,
    kNextZoomTablePos = 2,
    kPrevZoomTablePos = 3,
    CMD_NOT_SET = 0,
  };

  static inline const Zoom* internal_default_instance() {
    return reinterpret_cast<const Zoom*>(
               &_Zoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Zoom& a, Zoom& b) {
    a.Swap(&b);
  }
  inline void Swap(Zoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Zoom* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Zoom* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Zoom>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Zoom& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Zoom& from) {
    Zoom::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Zoom* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.Zoom";
  }
  protected:
  explicit Zoom(::google::protobuf::Arena* arena);
  Zoom(::google::protobuf::Arena* arena, const Zoom& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSetZoomTableValueFieldNumber = 1,
    kNextZoomTablePosFieldNumber = 2,
    kPrevZoomTablePosFieldNumber = 3,
  };
  // .cmd.HeatCamera.SetZoomTableValue set_zoom_table_value = 1;
  bool has_set_zoom_table_value() const;
  private:
  bool _internal_has_set_zoom_table_value() const;

  public:
  void clear_set_zoom_table_value() ;
  const ::cmd::HeatCamera::SetZoomTableValue& set_zoom_table_value() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::SetZoomTableValue* release_set_zoom_table_value();
  ::cmd::HeatCamera::SetZoomTableValue* mutable_set_zoom_table_value();
  void set_allocated_set_zoom_table_value(::cmd::HeatCamera::SetZoomTableValue* value);
  void unsafe_arena_set_allocated_set_zoom_table_value(::cmd::HeatCamera::SetZoomTableValue* value);
  ::cmd::HeatCamera::SetZoomTableValue* unsafe_arena_release_set_zoom_table_value();

  private:
  const ::cmd::HeatCamera::SetZoomTableValue& _internal_set_zoom_table_value() const;
  ::cmd::HeatCamera::SetZoomTableValue* _internal_mutable_set_zoom_table_value();

  public:
  // .cmd.HeatCamera.NextZoomTablePos next_zoom_table_pos = 2;
  bool has_next_zoom_table_pos() const;
  private:
  bool _internal_has_next_zoom_table_pos() const;

  public:
  void clear_next_zoom_table_pos() ;
  const ::cmd::HeatCamera::NextZoomTablePos& next_zoom_table_pos() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::NextZoomTablePos* release_next_zoom_table_pos();
  ::cmd::HeatCamera::NextZoomTablePos* mutable_next_zoom_table_pos();
  void set_allocated_next_zoom_table_pos(::cmd::HeatCamera::NextZoomTablePos* value);
  void unsafe_arena_set_allocated_next_zoom_table_pos(::cmd::HeatCamera::NextZoomTablePos* value);
  ::cmd::HeatCamera::NextZoomTablePos* unsafe_arena_release_next_zoom_table_pos();

  private:
  const ::cmd::HeatCamera::NextZoomTablePos& _internal_next_zoom_table_pos() const;
  ::cmd::HeatCamera::NextZoomTablePos* _internal_mutable_next_zoom_table_pos();

  public:
  // .cmd.HeatCamera.PrevZoomTablePos prev_zoom_table_pos = 3;
  bool has_prev_zoom_table_pos() const;
  private:
  bool _internal_has_prev_zoom_table_pos() const;

  public:
  void clear_prev_zoom_table_pos() ;
  const ::cmd::HeatCamera::PrevZoomTablePos& prev_zoom_table_pos() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::PrevZoomTablePos* release_prev_zoom_table_pos();
  ::cmd::HeatCamera::PrevZoomTablePos* mutable_prev_zoom_table_pos();
  void set_allocated_prev_zoom_table_pos(::cmd::HeatCamera::PrevZoomTablePos* value);
  void unsafe_arena_set_allocated_prev_zoom_table_pos(::cmd::HeatCamera::PrevZoomTablePos* value);
  ::cmd::HeatCamera::PrevZoomTablePos* unsafe_arena_release_prev_zoom_table_pos();

  private:
  const ::cmd::HeatCamera::PrevZoomTablePos& _internal_prev_zoom_table_pos() const;
  ::cmd::HeatCamera::PrevZoomTablePos* _internal_mutable_prev_zoom_table_pos();

  public:
  void clear_cmd();
  CmdCase cmd_case() const;
  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.Zoom)
 private:
  class _Internal;
  void set_has_set_zoom_table_value();
  void set_has_next_zoom_table_pos();
  void set_has_prev_zoom_table_pos();

  inline bool has_cmd() const;
  inline void clear_has_cmd();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 3, 3,
      0, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union CmdUnion {
      constexpr CmdUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cmd::HeatCamera::SetZoomTableValue* set_zoom_table_value_;
      ::cmd::HeatCamera::NextZoomTablePos* next_zoom_table_pos_;
      ::cmd::HeatCamera::PrevZoomTablePos* prev_zoom_table_pos_;
    } cmd_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};// -------------------------------------------------------------------

class Root final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cmd.HeatCamera.Root) */ {
 public:
  inline Root() : Root(nullptr) {}
  ~Root() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR Root(::google::protobuf::internal::ConstantInitialized);

  inline Root(const Root& from)
      : Root(nullptr, from) {}
  Root(Root&& from) noexcept
    : Root() {
    *this = ::std::move(from);
  }

  inline Root& operator=(const Root& from) {
    CopyFrom(from);
    return *this;
  }
  inline Root& operator=(Root&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Root& default_instance() {
    return *internal_default_instance();
  }
  enum CmdCase {
    kZoom = 1,
    kSetAgc = 2,
    kSetFilter = 3,
    kStart = 4,
    kStop = 5,
    kPhoto = 6,
    kZoomIn = 10,
    kZoomOut = 11,
    kZoomStop = 12,
    kFocusIn = 13,
    kFocusOut = 14,
    kFocusStop = 15,
    kCalibrate = 16,
    kSetDdeLevel = 17,
    kEnableDde = 18,
    kDisableDde = 19,
    kSetAutoFocus = 20,
    kFocusStepPlus = 21,
    kFocusStepMinus = 22,
    kSetFxMode = 23,
    kNextFxMode = 24,
    kPrevFxMode = 25,
    kGetMeteo = 26,
    kShiftDde = 27,
    kRefreshFxMode = 28,
    kResetZoom = 29,
    kSaveToTable = 30,
    kSetCalibMode = 31,
    kSetDigitalZoomLevel = 32,
    kSetClaheLevel = 33,
    kShiftClaheLevel = 34,
    CMD_NOT_SET = 0,
  };

  static inline const Root* internal_default_instance() {
    return reinterpret_cast<const Root*>(
               &_Root_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Root& a, Root& b) {
    a.Swap(&b);
  }
  inline void Swap(Root* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Root* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Root* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Root>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Root& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const Root& from) {
    Root::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(Root* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "cmd.HeatCamera.Root";
  }
  protected:
  explicit Root(::google::protobuf::Arena* arena);
  Root(::google::protobuf::Arena* arena, const Root& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kZoomFieldNumber = 1,
    kSetAgcFieldNumber = 2,
    kSetFilterFieldNumber = 3,
    kStartFieldNumber = 4,
    kStopFieldNumber = 5,
    kPhotoFieldNumber = 6,
    kZoomInFieldNumber = 10,
    kZoomOutFieldNumber = 11,
    kZoomStopFieldNumber = 12,
    kFocusInFieldNumber = 13,
    kFocusOutFieldNumber = 14,
    kFocusStopFieldNumber = 15,
    kCalibrateFieldNumber = 16,
    kSetDdeLevelFieldNumber = 17,
    kEnableDdeFieldNumber = 18,
    kDisableDdeFieldNumber = 19,
    kSetAutoFocusFieldNumber = 20,
    kFocusStepPlusFieldNumber = 21,
    kFocusStepMinusFieldNumber = 22,
    kSetFxModeFieldNumber = 23,
    kNextFxModeFieldNumber = 24,
    kPrevFxModeFieldNumber = 25,
    kGetMeteoFieldNumber = 26,
    kShiftDdeFieldNumber = 27,
    kRefreshFxModeFieldNumber = 28,
    kResetZoomFieldNumber = 29,
    kSaveToTableFieldNumber = 30,
    kSetCalibModeFieldNumber = 31,
    kSetDigitalZoomLevelFieldNumber = 32,
    kSetClaheLevelFieldNumber = 33,
    kShiftClaheLevelFieldNumber = 34,
  };
  // .cmd.HeatCamera.Zoom zoom = 1;
  bool has_zoom() const;
  private:
  bool _internal_has_zoom() const;

  public:
  void clear_zoom() ;
  const ::cmd::HeatCamera::Zoom& zoom() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::Zoom* release_zoom();
  ::cmd::HeatCamera::Zoom* mutable_zoom();
  void set_allocated_zoom(::cmd::HeatCamera::Zoom* value);
  void unsafe_arena_set_allocated_zoom(::cmd::HeatCamera::Zoom* value);
  ::cmd::HeatCamera::Zoom* unsafe_arena_release_zoom();

  private:
  const ::cmd::HeatCamera::Zoom& _internal_zoom() const;
  ::cmd::HeatCamera::Zoom* _internal_mutable_zoom();

  public:
  // .cmd.HeatCamera.SetAGC set_agc = 2;
  bool has_set_agc() const;
  private:
  bool _internal_has_set_agc() const;

  public:
  void clear_set_agc() ;
  const ::cmd::HeatCamera::SetAGC& set_agc() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::SetAGC* release_set_agc();
  ::cmd::HeatCamera::SetAGC* mutable_set_agc();
  void set_allocated_set_agc(::cmd::HeatCamera::SetAGC* value);
  void unsafe_arena_set_allocated_set_agc(::cmd::HeatCamera::SetAGC* value);
  ::cmd::HeatCamera::SetAGC* unsafe_arena_release_set_agc();

  private:
  const ::cmd::HeatCamera::SetAGC& _internal_set_agc() const;
  ::cmd::HeatCamera::SetAGC* _internal_mutable_set_agc();

  public:
  // .cmd.HeatCamera.SetFilters set_filter = 3;
  bool has_set_filter() const;
  private:
  bool _internal_has_set_filter() const;

  public:
  void clear_set_filter() ;
  const ::cmd::HeatCamera::SetFilters& set_filter() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::SetFilters* release_set_filter();
  ::cmd::HeatCamera::SetFilters* mutable_set_filter();
  void set_allocated_set_filter(::cmd::HeatCamera::SetFilters* value);
  void unsafe_arena_set_allocated_set_filter(::cmd::HeatCamera::SetFilters* value);
  ::cmd::HeatCamera::SetFilters* unsafe_arena_release_set_filter();

  private:
  const ::cmd::HeatCamera::SetFilters& _internal_set_filter() const;
  ::cmd::HeatCamera::SetFilters* _internal_mutable_set_filter();

  public:
  // .cmd.HeatCamera.Start start = 4;
  bool has_start() const;
  private:
  bool _internal_has_start() const;

  public:
  void clear_start() ;
  const ::cmd::HeatCamera::Start& start() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::Start* release_start();
  ::cmd::HeatCamera::Start* mutable_start();
  void set_allocated_start(::cmd::HeatCamera::Start* value);
  void unsafe_arena_set_allocated_start(::cmd::HeatCamera::Start* value);
  ::cmd::HeatCamera::Start* unsafe_arena_release_start();

  private:
  const ::cmd::HeatCamera::Start& _internal_start() const;
  ::cmd::HeatCamera::Start* _internal_mutable_start();

  public:
  // .cmd.HeatCamera.Stop stop = 5;
  bool has_stop() const;
  private:
  bool _internal_has_stop() const;

  public:
  void clear_stop() ;
  const ::cmd::HeatCamera::Stop& stop() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::Stop* release_stop();
  ::cmd::HeatCamera::Stop* mutable_stop();
  void set_allocated_stop(::cmd::HeatCamera::Stop* value);
  void unsafe_arena_set_allocated_stop(::cmd::HeatCamera::Stop* value);
  ::cmd::HeatCamera::Stop* unsafe_arena_release_stop();

  private:
  const ::cmd::HeatCamera::Stop& _internal_stop() const;
  ::cmd::HeatCamera::Stop* _internal_mutable_stop();

  public:
  // .cmd.HeatCamera.Photo photo = 6;
  bool has_photo() const;
  private:
  bool _internal_has_photo() const;

  public:
  void clear_photo() ;
  const ::cmd::HeatCamera::Photo& photo() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::Photo* release_photo();
  ::cmd::HeatCamera::Photo* mutable_photo();
  void set_allocated_photo(::cmd::HeatCamera::Photo* value);
  void unsafe_arena_set_allocated_photo(::cmd::HeatCamera::Photo* value);
  ::cmd::HeatCamera::Photo* unsafe_arena_release_photo();

  private:
  const ::cmd::HeatCamera::Photo& _internal_photo() const;
  ::cmd::HeatCamera::Photo* _internal_mutable_photo();

  public:
  // .cmd.HeatCamera.ZoomIn zoom_in = 10;
  bool has_zoom_in() const;
  private:
  bool _internal_has_zoom_in() const;

  public:
  void clear_zoom_in() ;
  const ::cmd::HeatCamera::ZoomIn& zoom_in() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::ZoomIn* release_zoom_in();
  ::cmd::HeatCamera::ZoomIn* mutable_zoom_in();
  void set_allocated_zoom_in(::cmd::HeatCamera::ZoomIn* value);
  void unsafe_arena_set_allocated_zoom_in(::cmd::HeatCamera::ZoomIn* value);
  ::cmd::HeatCamera::ZoomIn* unsafe_arena_release_zoom_in();

  private:
  const ::cmd::HeatCamera::ZoomIn& _internal_zoom_in() const;
  ::cmd::HeatCamera::ZoomIn* _internal_mutable_zoom_in();

  public:
  // .cmd.HeatCamera.ZoomOut zoom_out = 11;
  bool has_zoom_out() const;
  private:
  bool _internal_has_zoom_out() const;

  public:
  void clear_zoom_out() ;
  const ::cmd::HeatCamera::ZoomOut& zoom_out() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::ZoomOut* release_zoom_out();
  ::cmd::HeatCamera::ZoomOut* mutable_zoom_out();
  void set_allocated_zoom_out(::cmd::HeatCamera::ZoomOut* value);
  void unsafe_arena_set_allocated_zoom_out(::cmd::HeatCamera::ZoomOut* value);
  ::cmd::HeatCamera::ZoomOut* unsafe_arena_release_zoom_out();

  private:
  const ::cmd::HeatCamera::ZoomOut& _internal_zoom_out() const;
  ::cmd::HeatCamera::ZoomOut* _internal_mutable_zoom_out();

  public:
  // .cmd.HeatCamera.ZoomStop zoom_stop = 12;
  bool has_zoom_stop() const;
  private:
  bool _internal_has_zoom_stop() const;

  public:
  void clear_zoom_stop() ;
  const ::cmd::HeatCamera::ZoomStop& zoom_stop() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::ZoomStop* release_zoom_stop();
  ::cmd::HeatCamera::ZoomStop* mutable_zoom_stop();
  void set_allocated_zoom_stop(::cmd::HeatCamera::ZoomStop* value);
  void unsafe_arena_set_allocated_zoom_stop(::cmd::HeatCamera::ZoomStop* value);
  ::cmd::HeatCamera::ZoomStop* unsafe_arena_release_zoom_stop();

  private:
  const ::cmd::HeatCamera::ZoomStop& _internal_zoom_stop() const;
  ::cmd::HeatCamera::ZoomStop* _internal_mutable_zoom_stop();

  public:
  // .cmd.HeatCamera.FocusIn focus_in = 13;
  bool has_focus_in() const;
  private:
  bool _internal_has_focus_in() const;

  public:
  void clear_focus_in() ;
  const ::cmd::HeatCamera::FocusIn& focus_in() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::FocusIn* release_focus_in();
  ::cmd::HeatCamera::FocusIn* mutable_focus_in();
  void set_allocated_focus_in(::cmd::HeatCamera::FocusIn* value);
  void unsafe_arena_set_allocated_focus_in(::cmd::HeatCamera::FocusIn* value);
  ::cmd::HeatCamera::FocusIn* unsafe_arena_release_focus_in();

  private:
  const ::cmd::HeatCamera::FocusIn& _internal_focus_in() const;
  ::cmd::HeatCamera::FocusIn* _internal_mutable_focus_in();

  public:
  // .cmd.HeatCamera.FocusOut focus_out = 14;
  bool has_focus_out() const;
  private:
  bool _internal_has_focus_out() const;

  public:
  void clear_focus_out() ;
  const ::cmd::HeatCamera::FocusOut& focus_out() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::FocusOut* release_focus_out();
  ::cmd::HeatCamera::FocusOut* mutable_focus_out();
  void set_allocated_focus_out(::cmd::HeatCamera::FocusOut* value);
  void unsafe_arena_set_allocated_focus_out(::cmd::HeatCamera::FocusOut* value);
  ::cmd::HeatCamera::FocusOut* unsafe_arena_release_focus_out();

  private:
  const ::cmd::HeatCamera::FocusOut& _internal_focus_out() const;
  ::cmd::HeatCamera::FocusOut* _internal_mutable_focus_out();

  public:
  // .cmd.HeatCamera.FocusStop focus_stop = 15;
  bool has_focus_stop() const;
  private:
  bool _internal_has_focus_stop() const;

  public:
  void clear_focus_stop() ;
  const ::cmd::HeatCamera::FocusStop& focus_stop() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::FocusStop* release_focus_stop();
  ::cmd::HeatCamera::FocusStop* mutable_focus_stop();
  void set_allocated_focus_stop(::cmd::HeatCamera::FocusStop* value);
  void unsafe_arena_set_allocated_focus_stop(::cmd::HeatCamera::FocusStop* value);
  ::cmd::HeatCamera::FocusStop* unsafe_arena_release_focus_stop();

  private:
  const ::cmd::HeatCamera::FocusStop& _internal_focus_stop() const;
  ::cmd::HeatCamera::FocusStop* _internal_mutable_focus_stop();

  public:
  // .cmd.HeatCamera.Calibrate calibrate = 16;
  bool has_calibrate() const;
  private:
  bool _internal_has_calibrate() const;

  public:
  void clear_calibrate() ;
  const ::cmd::HeatCamera::Calibrate& calibrate() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::Calibrate* release_calibrate();
  ::cmd::HeatCamera::Calibrate* mutable_calibrate();
  void set_allocated_calibrate(::cmd::HeatCamera::Calibrate* value);
  void unsafe_arena_set_allocated_calibrate(::cmd::HeatCamera::Calibrate* value);
  ::cmd::HeatCamera::Calibrate* unsafe_arena_release_calibrate();

  private:
  const ::cmd::HeatCamera::Calibrate& _internal_calibrate() const;
  ::cmd::HeatCamera::Calibrate* _internal_mutable_calibrate();

  public:
  // .cmd.HeatCamera.SetDDELevel set_dde_level = 17;
  bool has_set_dde_level() const;
  private:
  bool _internal_has_set_dde_level() const;

  public:
  void clear_set_dde_level() ;
  const ::cmd::HeatCamera::SetDDELevel& set_dde_level() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::SetDDELevel* release_set_dde_level();
  ::cmd::HeatCamera::SetDDELevel* mutable_set_dde_level();
  void set_allocated_set_dde_level(::cmd::HeatCamera::SetDDELevel* value);
  void unsafe_arena_set_allocated_set_dde_level(::cmd::HeatCamera::SetDDELevel* value);
  ::cmd::HeatCamera::SetDDELevel* unsafe_arena_release_set_dde_level();

  private:
  const ::cmd::HeatCamera::SetDDELevel& _internal_set_dde_level() const;
  ::cmd::HeatCamera::SetDDELevel* _internal_mutable_set_dde_level();

  public:
  // .cmd.HeatCamera.EnableDDE enable_dde = 18;
  bool has_enable_dde() const;
  private:
  bool _internal_has_enable_dde() const;

  public:
  void clear_enable_dde() ;
  const ::cmd::HeatCamera::EnableDDE& enable_dde() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::EnableDDE* release_enable_dde();
  ::cmd::HeatCamera::EnableDDE* mutable_enable_dde();
  void set_allocated_enable_dde(::cmd::HeatCamera::EnableDDE* value);
  void unsafe_arena_set_allocated_enable_dde(::cmd::HeatCamera::EnableDDE* value);
  ::cmd::HeatCamera::EnableDDE* unsafe_arena_release_enable_dde();

  private:
  const ::cmd::HeatCamera::EnableDDE& _internal_enable_dde() const;
  ::cmd::HeatCamera::EnableDDE* _internal_mutable_enable_dde();

  public:
  // .cmd.HeatCamera.DisableDDE disable_dde = 19;
  bool has_disable_dde() const;
  private:
  bool _internal_has_disable_dde() const;

  public:
  void clear_disable_dde() ;
  const ::cmd::HeatCamera::DisableDDE& disable_dde() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::DisableDDE* release_disable_dde();
  ::cmd::HeatCamera::DisableDDE* mutable_disable_dde();
  void set_allocated_disable_dde(::cmd::HeatCamera::DisableDDE* value);
  void unsafe_arena_set_allocated_disable_dde(::cmd::HeatCamera::DisableDDE* value);
  ::cmd::HeatCamera::DisableDDE* unsafe_arena_release_disable_dde();

  private:
  const ::cmd::HeatCamera::DisableDDE& _internal_disable_dde() const;
  ::cmd::HeatCamera::DisableDDE* _internal_mutable_disable_dde();

  public:
  // .cmd.HeatCamera.SetAutoFocus set_auto_focus = 20;
  bool has_set_auto_focus() const;
  private:
  bool _internal_has_set_auto_focus() const;

  public:
  void clear_set_auto_focus() ;
  const ::cmd::HeatCamera::SetAutoFocus& set_auto_focus() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::SetAutoFocus* release_set_auto_focus();
  ::cmd::HeatCamera::SetAutoFocus* mutable_set_auto_focus();
  void set_allocated_set_auto_focus(::cmd::HeatCamera::SetAutoFocus* value);
  void unsafe_arena_set_allocated_set_auto_focus(::cmd::HeatCamera::SetAutoFocus* value);
  ::cmd::HeatCamera::SetAutoFocus* unsafe_arena_release_set_auto_focus();

  private:
  const ::cmd::HeatCamera::SetAutoFocus& _internal_set_auto_focus() const;
  ::cmd::HeatCamera::SetAutoFocus* _internal_mutable_set_auto_focus();

  public:
  // .cmd.HeatCamera.FocusStepPlus focus_step_plus = 21;
  bool has_focus_step_plus() const;
  private:
  bool _internal_has_focus_step_plus() const;

  public:
  void clear_focus_step_plus() ;
  const ::cmd::HeatCamera::FocusStepPlus& focus_step_plus() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::FocusStepPlus* release_focus_step_plus();
  ::cmd::HeatCamera::FocusStepPlus* mutable_focus_step_plus();
  void set_allocated_focus_step_plus(::cmd::HeatCamera::FocusStepPlus* value);
  void unsafe_arena_set_allocated_focus_step_plus(::cmd::HeatCamera::FocusStepPlus* value);
  ::cmd::HeatCamera::FocusStepPlus* unsafe_arena_release_focus_step_plus();

  private:
  const ::cmd::HeatCamera::FocusStepPlus& _internal_focus_step_plus() const;
  ::cmd::HeatCamera::FocusStepPlus* _internal_mutable_focus_step_plus();

  public:
  // .cmd.HeatCamera.FocusStepMinus focus_step_minus = 22;
  bool has_focus_step_minus() const;
  private:
  bool _internal_has_focus_step_minus() const;

  public:
  void clear_focus_step_minus() ;
  const ::cmd::HeatCamera::FocusStepMinus& focus_step_minus() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::FocusStepMinus* release_focus_step_minus();
  ::cmd::HeatCamera::FocusStepMinus* mutable_focus_step_minus();
  void set_allocated_focus_step_minus(::cmd::HeatCamera::FocusStepMinus* value);
  void unsafe_arena_set_allocated_focus_step_minus(::cmd::HeatCamera::FocusStepMinus* value);
  ::cmd::HeatCamera::FocusStepMinus* unsafe_arena_release_focus_step_minus();

  private:
  const ::cmd::HeatCamera::FocusStepMinus& _internal_focus_step_minus() const;
  ::cmd::HeatCamera::FocusStepMinus* _internal_mutable_focus_step_minus();

  public:
  // .cmd.HeatCamera.SetFxMode set_fx_mode = 23;
  bool has_set_fx_mode() const;
  private:
  bool _internal_has_set_fx_mode() const;

  public:
  void clear_set_fx_mode() ;
  const ::cmd::HeatCamera::SetFxMode& set_fx_mode() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::SetFxMode* release_set_fx_mode();
  ::cmd::HeatCamera::SetFxMode* mutable_set_fx_mode();
  void set_allocated_set_fx_mode(::cmd::HeatCamera::SetFxMode* value);
  void unsafe_arena_set_allocated_set_fx_mode(::cmd::HeatCamera::SetFxMode* value);
  ::cmd::HeatCamera::SetFxMode* unsafe_arena_release_set_fx_mode();

  private:
  const ::cmd::HeatCamera::SetFxMode& _internal_set_fx_mode() const;
  ::cmd::HeatCamera::SetFxMode* _internal_mutable_set_fx_mode();

  public:
  // .cmd.HeatCamera.NextFxMode next_fx_mode = 24;
  bool has_next_fx_mode() const;
  private:
  bool _internal_has_next_fx_mode() const;

  public:
  void clear_next_fx_mode() ;
  const ::cmd::HeatCamera::NextFxMode& next_fx_mode() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::NextFxMode* release_next_fx_mode();
  ::cmd::HeatCamera::NextFxMode* mutable_next_fx_mode();
  void set_allocated_next_fx_mode(::cmd::HeatCamera::NextFxMode* value);
  void unsafe_arena_set_allocated_next_fx_mode(::cmd::HeatCamera::NextFxMode* value);
  ::cmd::HeatCamera::NextFxMode* unsafe_arena_release_next_fx_mode();

  private:
  const ::cmd::HeatCamera::NextFxMode& _internal_next_fx_mode() const;
  ::cmd::HeatCamera::NextFxMode* _internal_mutable_next_fx_mode();

  public:
  // .cmd.HeatCamera.PrevFxMode prev_fx_mode = 25;
  bool has_prev_fx_mode() const;
  private:
  bool _internal_has_prev_fx_mode() const;

  public:
  void clear_prev_fx_mode() ;
  const ::cmd::HeatCamera::PrevFxMode& prev_fx_mode() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::PrevFxMode* release_prev_fx_mode();
  ::cmd::HeatCamera::PrevFxMode* mutable_prev_fx_mode();
  void set_allocated_prev_fx_mode(::cmd::HeatCamera::PrevFxMode* value);
  void unsafe_arena_set_allocated_prev_fx_mode(::cmd::HeatCamera::PrevFxMode* value);
  ::cmd::HeatCamera::PrevFxMode* unsafe_arena_release_prev_fx_mode();

  private:
  const ::cmd::HeatCamera::PrevFxMode& _internal_prev_fx_mode() const;
  ::cmd::HeatCamera::PrevFxMode* _internal_mutable_prev_fx_mode();

  public:
  // .cmd.HeatCamera.GetMeteo get_meteo = 26;
  bool has_get_meteo() const;
  private:
  bool _internal_has_get_meteo() const;

  public:
  void clear_get_meteo() ;
  const ::cmd::HeatCamera::GetMeteo& get_meteo() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::GetMeteo* release_get_meteo();
  ::cmd::HeatCamera::GetMeteo* mutable_get_meteo();
  void set_allocated_get_meteo(::cmd::HeatCamera::GetMeteo* value);
  void unsafe_arena_set_allocated_get_meteo(::cmd::HeatCamera::GetMeteo* value);
  ::cmd::HeatCamera::GetMeteo* unsafe_arena_release_get_meteo();

  private:
  const ::cmd::HeatCamera::GetMeteo& _internal_get_meteo() const;
  ::cmd::HeatCamera::GetMeteo* _internal_mutable_get_meteo();

  public:
  // .cmd.HeatCamera.ShiftDDE shift_dde = 27;
  bool has_shift_dde() const;
  private:
  bool _internal_has_shift_dde() const;

  public:
  void clear_shift_dde() ;
  const ::cmd::HeatCamera::ShiftDDE& shift_dde() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::ShiftDDE* release_shift_dde();
  ::cmd::HeatCamera::ShiftDDE* mutable_shift_dde();
  void set_allocated_shift_dde(::cmd::HeatCamera::ShiftDDE* value);
  void unsafe_arena_set_allocated_shift_dde(::cmd::HeatCamera::ShiftDDE* value);
  ::cmd::HeatCamera::ShiftDDE* unsafe_arena_release_shift_dde();

  private:
  const ::cmd::HeatCamera::ShiftDDE& _internal_shift_dde() const;
  ::cmd::HeatCamera::ShiftDDE* _internal_mutable_shift_dde();

  public:
  // .cmd.HeatCamera.RefreshFxMode refresh_fx_mode = 28;
  bool has_refresh_fx_mode() const;
  private:
  bool _internal_has_refresh_fx_mode() const;

  public:
  void clear_refresh_fx_mode() ;
  const ::cmd::HeatCamera::RefreshFxMode& refresh_fx_mode() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::RefreshFxMode* release_refresh_fx_mode();
  ::cmd::HeatCamera::RefreshFxMode* mutable_refresh_fx_mode();
  void set_allocated_refresh_fx_mode(::cmd::HeatCamera::RefreshFxMode* value);
  void unsafe_arena_set_allocated_refresh_fx_mode(::cmd::HeatCamera::RefreshFxMode* value);
  ::cmd::HeatCamera::RefreshFxMode* unsafe_arena_release_refresh_fx_mode();

  private:
  const ::cmd::HeatCamera::RefreshFxMode& _internal_refresh_fx_mode() const;
  ::cmd::HeatCamera::RefreshFxMode* _internal_mutable_refresh_fx_mode();

  public:
  // .cmd.HeatCamera.ResetZoom reset_zoom = 29;
  bool has_reset_zoom() const;
  private:
  bool _internal_has_reset_zoom() const;

  public:
  void clear_reset_zoom() ;
  const ::cmd::HeatCamera::ResetZoom& reset_zoom() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::ResetZoom* release_reset_zoom();
  ::cmd::HeatCamera::ResetZoom* mutable_reset_zoom();
  void set_allocated_reset_zoom(::cmd::HeatCamera::ResetZoom* value);
  void unsafe_arena_set_allocated_reset_zoom(::cmd::HeatCamera::ResetZoom* value);
  ::cmd::HeatCamera::ResetZoom* unsafe_arena_release_reset_zoom();

  private:
  const ::cmd::HeatCamera::ResetZoom& _internal_reset_zoom() const;
  ::cmd::HeatCamera::ResetZoom* _internal_mutable_reset_zoom();

  public:
  // .cmd.HeatCamera.SaveToTable save_to_table = 30;
  bool has_save_to_table() const;
  private:
  bool _internal_has_save_to_table() const;

  public:
  void clear_save_to_table() ;
  const ::cmd::HeatCamera::SaveToTable& save_to_table() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::SaveToTable* release_save_to_table();
  ::cmd::HeatCamera::SaveToTable* mutable_save_to_table();
  void set_allocated_save_to_table(::cmd::HeatCamera::SaveToTable* value);
  void unsafe_arena_set_allocated_save_to_table(::cmd::HeatCamera::SaveToTable* value);
  ::cmd::HeatCamera::SaveToTable* unsafe_arena_release_save_to_table();

  private:
  const ::cmd::HeatCamera::SaveToTable& _internal_save_to_table() const;
  ::cmd::HeatCamera::SaveToTable* _internal_mutable_save_to_table();

  public:
  // .cmd.HeatCamera.SetCalibMode set_calib_mode = 31;
  bool has_set_calib_mode() const;
  private:
  bool _internal_has_set_calib_mode() const;

  public:
  void clear_set_calib_mode() ;
  const ::cmd::HeatCamera::SetCalibMode& set_calib_mode() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::SetCalibMode* release_set_calib_mode();
  ::cmd::HeatCamera::SetCalibMode* mutable_set_calib_mode();
  void set_allocated_set_calib_mode(::cmd::HeatCamera::SetCalibMode* value);
  void unsafe_arena_set_allocated_set_calib_mode(::cmd::HeatCamera::SetCalibMode* value);
  ::cmd::HeatCamera::SetCalibMode* unsafe_arena_release_set_calib_mode();

  private:
  const ::cmd::HeatCamera::SetCalibMode& _internal_set_calib_mode() const;
  ::cmd::HeatCamera::SetCalibMode* _internal_mutable_set_calib_mode();

  public:
  // .cmd.HeatCamera.SetDigitalZoomLevel set_digital_zoom_level = 32;
  bool has_set_digital_zoom_level() const;
  private:
  bool _internal_has_set_digital_zoom_level() const;

  public:
  void clear_set_digital_zoom_level() ;
  const ::cmd::HeatCamera::SetDigitalZoomLevel& set_digital_zoom_level() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::SetDigitalZoomLevel* release_set_digital_zoom_level();
  ::cmd::HeatCamera::SetDigitalZoomLevel* mutable_set_digital_zoom_level();
  void set_allocated_set_digital_zoom_level(::cmd::HeatCamera::SetDigitalZoomLevel* value);
  void unsafe_arena_set_allocated_set_digital_zoom_level(::cmd::HeatCamera::SetDigitalZoomLevel* value);
  ::cmd::HeatCamera::SetDigitalZoomLevel* unsafe_arena_release_set_digital_zoom_level();

  private:
  const ::cmd::HeatCamera::SetDigitalZoomLevel& _internal_set_digital_zoom_level() const;
  ::cmd::HeatCamera::SetDigitalZoomLevel* _internal_mutable_set_digital_zoom_level();

  public:
  // .cmd.HeatCamera.SetClaheLevel set_clahe_level = 33;
  bool has_set_clahe_level() const;
  private:
  bool _internal_has_set_clahe_level() const;

  public:
  void clear_set_clahe_level() ;
  const ::cmd::HeatCamera::SetClaheLevel& set_clahe_level() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::SetClaheLevel* release_set_clahe_level();
  ::cmd::HeatCamera::SetClaheLevel* mutable_set_clahe_level();
  void set_allocated_set_clahe_level(::cmd::HeatCamera::SetClaheLevel* value);
  void unsafe_arena_set_allocated_set_clahe_level(::cmd::HeatCamera::SetClaheLevel* value);
  ::cmd::HeatCamera::SetClaheLevel* unsafe_arena_release_set_clahe_level();

  private:
  const ::cmd::HeatCamera::SetClaheLevel& _internal_set_clahe_level() const;
  ::cmd::HeatCamera::SetClaheLevel* _internal_mutable_set_clahe_level();

  public:
  // .cmd.HeatCamera.ShiftClaheLevel shift_clahe_level = 34;
  bool has_shift_clahe_level() const;
  private:
  bool _internal_has_shift_clahe_level() const;

  public:
  void clear_shift_clahe_level() ;
  const ::cmd::HeatCamera::ShiftClaheLevel& shift_clahe_level() const;
  PROTOBUF_NODISCARD ::cmd::HeatCamera::ShiftClaheLevel* release_shift_clahe_level();
  ::cmd::HeatCamera::ShiftClaheLevel* mutable_shift_clahe_level();
  void set_allocated_shift_clahe_level(::cmd::HeatCamera::ShiftClaheLevel* value);
  void unsafe_arena_set_allocated_shift_clahe_level(::cmd::HeatCamera::ShiftClaheLevel* value);
  ::cmd::HeatCamera::ShiftClaheLevel* unsafe_arena_release_shift_clahe_level();

  private:
  const ::cmd::HeatCamera::ShiftClaheLevel& _internal_shift_clahe_level() const;
  ::cmd::HeatCamera::ShiftClaheLevel* _internal_mutable_shift_clahe_level();

  public:
  void clear_cmd();
  CmdCase cmd_case() const;
  // @@protoc_insertion_point(class_scope:cmd.HeatCamera.Root)
 private:
  class _Internal;
  void set_has_zoom();
  void set_has_set_agc();
  void set_has_set_filter();
  void set_has_start();
  void set_has_stop();
  void set_has_photo();
  void set_has_zoom_in();
  void set_has_zoom_out();
  void set_has_zoom_stop();
  void set_has_focus_in();
  void set_has_focus_out();
  void set_has_focus_stop();
  void set_has_calibrate();
  void set_has_set_dde_level();
  void set_has_enable_dde();
  void set_has_disable_dde();
  void set_has_set_auto_focus();
  void set_has_focus_step_plus();
  void set_has_focus_step_minus();
  void set_has_set_fx_mode();
  void set_has_next_fx_mode();
  void set_has_prev_fx_mode();
  void set_has_get_meteo();
  void set_has_shift_dde();
  void set_has_refresh_fx_mode();
  void set_has_reset_zoom();
  void set_has_save_to_table();
  void set_has_set_calib_mode();
  void set_has_set_digital_zoom_level();
  void set_has_set_clahe_level();
  void set_has_shift_clahe_level();

  inline bool has_cmd() const;
  inline void clear_has_cmd();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 31, 31,
      0, 7>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    union CmdUnion {
      constexpr CmdUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::cmd::HeatCamera::Zoom* zoom_;
      ::cmd::HeatCamera::SetAGC* set_agc_;
      ::cmd::HeatCamera::SetFilters* set_filter_;
      ::cmd::HeatCamera::Start* start_;
      ::cmd::HeatCamera::Stop* stop_;
      ::cmd::HeatCamera::Photo* photo_;
      ::cmd::HeatCamera::ZoomIn* zoom_in_;
      ::cmd::HeatCamera::ZoomOut* zoom_out_;
      ::cmd::HeatCamera::ZoomStop* zoom_stop_;
      ::cmd::HeatCamera::FocusIn* focus_in_;
      ::cmd::HeatCamera::FocusOut* focus_out_;
      ::cmd::HeatCamera::FocusStop* focus_stop_;
      ::cmd::HeatCamera::Calibrate* calibrate_;
      ::cmd::HeatCamera::SetDDELevel* set_dde_level_;
      ::cmd::HeatCamera::EnableDDE* enable_dde_;
      ::cmd::HeatCamera::DisableDDE* disable_dde_;
      ::cmd::HeatCamera::SetAutoFocus* set_auto_focus_;
      ::cmd::HeatCamera::FocusStepPlus* focus_step_plus_;
      ::cmd::HeatCamera::FocusStepMinus* focus_step_minus_;
      ::cmd::HeatCamera::SetFxMode* set_fx_mode_;
      ::cmd::HeatCamera::NextFxMode* next_fx_mode_;
      ::cmd::HeatCamera::PrevFxMode* prev_fx_mode_;
      ::cmd::HeatCamera::GetMeteo* get_meteo_;
      ::cmd::HeatCamera::ShiftDDE* shift_dde_;
      ::cmd::HeatCamera::RefreshFxMode* refresh_fx_mode_;
      ::cmd::HeatCamera::ResetZoom* reset_zoom_;
      ::cmd::HeatCamera::SaveToTable* save_to_table_;
      ::cmd::HeatCamera::SetCalibMode* set_calib_mode_;
      ::cmd::HeatCamera::SetDigitalZoomLevel* set_digital_zoom_level_;
      ::cmd::HeatCamera::SetClaheLevel* set_clahe_level_;
      ::cmd::HeatCamera::ShiftClaheLevel* shift_clahe_level_;
    } cmd_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Root

// .cmd.HeatCamera.Zoom zoom = 1;
inline bool Root::has_zoom() const {
  return cmd_case() == kZoom;
}
inline bool Root::_internal_has_zoom() const {
  return cmd_case() == kZoom;
}
inline void Root::set_has_zoom() {
  _impl_._oneof_case_[0] = kZoom;
}
inline void Root::clear_zoom() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kZoom) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.zoom_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::Zoom* Root::release_zoom() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.zoom)
  if (cmd_case() == kZoom) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.zoom_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.zoom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::Zoom& Root::_internal_zoom() const {
  return cmd_case() == kZoom ? *_impl_.cmd_.zoom_ : reinterpret_cast<::cmd::HeatCamera::Zoom&>(::cmd::HeatCamera::_Zoom_default_instance_);
}
inline const ::cmd::HeatCamera::Zoom& Root::zoom() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.zoom)
  return _internal_zoom();
}
inline ::cmd::HeatCamera::Zoom* Root::unsafe_arena_release_zoom() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.zoom)
  if (cmd_case() == kZoom) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.zoom_;
    _impl_.cmd_.zoom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_zoom(::cmd::HeatCamera::Zoom* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_zoom();
    _impl_.cmd_.zoom_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.zoom)
}
inline ::cmd::HeatCamera::Zoom* Root::_internal_mutable_zoom() {
  if (cmd_case() != kZoom) {
    clear_cmd();
    set_has_zoom();
    _impl_.cmd_.zoom_ = CreateMaybeMessage<::cmd::HeatCamera::Zoom>(GetArena());
  }
  return _impl_.cmd_.zoom_;
}
inline ::cmd::HeatCamera::Zoom* Root::mutable_zoom() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::Zoom* _msg = _internal_mutable_zoom();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.zoom)
  return _msg;
}

// .cmd.HeatCamera.SetAGC set_agc = 2;
inline bool Root::has_set_agc() const {
  return cmd_case() == kSetAgc;
}
inline bool Root::_internal_has_set_agc() const {
  return cmd_case() == kSetAgc;
}
inline void Root::set_has_set_agc() {
  _impl_._oneof_case_[0] = kSetAgc;
}
inline void Root::clear_set_agc() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kSetAgc) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.set_agc_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::SetAGC* Root::release_set_agc() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.set_agc)
  if (cmd_case() == kSetAgc) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_agc_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.set_agc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::SetAGC& Root::_internal_set_agc() const {
  return cmd_case() == kSetAgc ? *_impl_.cmd_.set_agc_ : reinterpret_cast<::cmd::HeatCamera::SetAGC&>(::cmd::HeatCamera::_SetAGC_default_instance_);
}
inline const ::cmd::HeatCamera::SetAGC& Root::set_agc() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.set_agc)
  return _internal_set_agc();
}
inline ::cmd::HeatCamera::SetAGC* Root::unsafe_arena_release_set_agc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.set_agc)
  if (cmd_case() == kSetAgc) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_agc_;
    _impl_.cmd_.set_agc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_set_agc(::cmd::HeatCamera::SetAGC* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_set_agc();
    _impl_.cmd_.set_agc_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.set_agc)
}
inline ::cmd::HeatCamera::SetAGC* Root::_internal_mutable_set_agc() {
  if (cmd_case() != kSetAgc) {
    clear_cmd();
    set_has_set_agc();
    _impl_.cmd_.set_agc_ = CreateMaybeMessage<::cmd::HeatCamera::SetAGC>(GetArena());
  }
  return _impl_.cmd_.set_agc_;
}
inline ::cmd::HeatCamera::SetAGC* Root::mutable_set_agc() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::SetAGC* _msg = _internal_mutable_set_agc();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.set_agc)
  return _msg;
}

// .cmd.HeatCamera.SetFilters set_filter = 3;
inline bool Root::has_set_filter() const {
  return cmd_case() == kSetFilter;
}
inline bool Root::_internal_has_set_filter() const {
  return cmd_case() == kSetFilter;
}
inline void Root::set_has_set_filter() {
  _impl_._oneof_case_[0] = kSetFilter;
}
inline void Root::clear_set_filter() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kSetFilter) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.set_filter_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::SetFilters* Root::release_set_filter() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.set_filter)
  if (cmd_case() == kSetFilter) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_filter_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.set_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::SetFilters& Root::_internal_set_filter() const {
  return cmd_case() == kSetFilter ? *_impl_.cmd_.set_filter_ : reinterpret_cast<::cmd::HeatCamera::SetFilters&>(::cmd::HeatCamera::_SetFilters_default_instance_);
}
inline const ::cmd::HeatCamera::SetFilters& Root::set_filter() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.set_filter)
  return _internal_set_filter();
}
inline ::cmd::HeatCamera::SetFilters* Root::unsafe_arena_release_set_filter() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.set_filter)
  if (cmd_case() == kSetFilter) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_filter_;
    _impl_.cmd_.set_filter_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_set_filter(::cmd::HeatCamera::SetFilters* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_set_filter();
    _impl_.cmd_.set_filter_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.set_filter)
}
inline ::cmd::HeatCamera::SetFilters* Root::_internal_mutable_set_filter() {
  if (cmd_case() != kSetFilter) {
    clear_cmd();
    set_has_set_filter();
    _impl_.cmd_.set_filter_ = CreateMaybeMessage<::cmd::HeatCamera::SetFilters>(GetArena());
  }
  return _impl_.cmd_.set_filter_;
}
inline ::cmd::HeatCamera::SetFilters* Root::mutable_set_filter() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::SetFilters* _msg = _internal_mutable_set_filter();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.set_filter)
  return _msg;
}

// .cmd.HeatCamera.Start start = 4;
inline bool Root::has_start() const {
  return cmd_case() == kStart;
}
inline bool Root::_internal_has_start() const {
  return cmd_case() == kStart;
}
inline void Root::set_has_start() {
  _impl_._oneof_case_[0] = kStart;
}
inline void Root::clear_start() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kStart) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.start_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::Start* Root::release_start() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.start)
  if (cmd_case() == kStart) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.start_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.start_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::Start& Root::_internal_start() const {
  return cmd_case() == kStart ? *_impl_.cmd_.start_ : reinterpret_cast<::cmd::HeatCamera::Start&>(::cmd::HeatCamera::_Start_default_instance_);
}
inline const ::cmd::HeatCamera::Start& Root::start() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.start)
  return _internal_start();
}
inline ::cmd::HeatCamera::Start* Root::unsafe_arena_release_start() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.start)
  if (cmd_case() == kStart) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.start_;
    _impl_.cmd_.start_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_start(::cmd::HeatCamera::Start* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_start();
    _impl_.cmd_.start_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.start)
}
inline ::cmd::HeatCamera::Start* Root::_internal_mutable_start() {
  if (cmd_case() != kStart) {
    clear_cmd();
    set_has_start();
    _impl_.cmd_.start_ = CreateMaybeMessage<::cmd::HeatCamera::Start>(GetArena());
  }
  return _impl_.cmd_.start_;
}
inline ::cmd::HeatCamera::Start* Root::mutable_start() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::Start* _msg = _internal_mutable_start();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.start)
  return _msg;
}

// .cmd.HeatCamera.Stop stop = 5;
inline bool Root::has_stop() const {
  return cmd_case() == kStop;
}
inline bool Root::_internal_has_stop() const {
  return cmd_case() == kStop;
}
inline void Root::set_has_stop() {
  _impl_._oneof_case_[0] = kStop;
}
inline void Root::clear_stop() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kStop) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.stop_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::Stop* Root::release_stop() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.stop)
  if (cmd_case() == kStop) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.stop_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::Stop& Root::_internal_stop() const {
  return cmd_case() == kStop ? *_impl_.cmd_.stop_ : reinterpret_cast<::cmd::HeatCamera::Stop&>(::cmd::HeatCamera::_Stop_default_instance_);
}
inline const ::cmd::HeatCamera::Stop& Root::stop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.stop)
  return _internal_stop();
}
inline ::cmd::HeatCamera::Stop* Root::unsafe_arena_release_stop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.stop)
  if (cmd_case() == kStop) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.stop_;
    _impl_.cmd_.stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_stop(::cmd::HeatCamera::Stop* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_stop();
    _impl_.cmd_.stop_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.stop)
}
inline ::cmd::HeatCamera::Stop* Root::_internal_mutable_stop() {
  if (cmd_case() != kStop) {
    clear_cmd();
    set_has_stop();
    _impl_.cmd_.stop_ = CreateMaybeMessage<::cmd::HeatCamera::Stop>(GetArena());
  }
  return _impl_.cmd_.stop_;
}
inline ::cmd::HeatCamera::Stop* Root::mutable_stop() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::Stop* _msg = _internal_mutable_stop();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.stop)
  return _msg;
}

// .cmd.HeatCamera.Photo photo = 6;
inline bool Root::has_photo() const {
  return cmd_case() == kPhoto;
}
inline bool Root::_internal_has_photo() const {
  return cmd_case() == kPhoto;
}
inline void Root::set_has_photo() {
  _impl_._oneof_case_[0] = kPhoto;
}
inline void Root::clear_photo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kPhoto) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.photo_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::Photo* Root::release_photo() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.photo)
  if (cmd_case() == kPhoto) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.photo_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.photo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::Photo& Root::_internal_photo() const {
  return cmd_case() == kPhoto ? *_impl_.cmd_.photo_ : reinterpret_cast<::cmd::HeatCamera::Photo&>(::cmd::HeatCamera::_Photo_default_instance_);
}
inline const ::cmd::HeatCamera::Photo& Root::photo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.photo)
  return _internal_photo();
}
inline ::cmd::HeatCamera::Photo* Root::unsafe_arena_release_photo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.photo)
  if (cmd_case() == kPhoto) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.photo_;
    _impl_.cmd_.photo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_photo(::cmd::HeatCamera::Photo* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_photo();
    _impl_.cmd_.photo_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.photo)
}
inline ::cmd::HeatCamera::Photo* Root::_internal_mutable_photo() {
  if (cmd_case() != kPhoto) {
    clear_cmd();
    set_has_photo();
    _impl_.cmd_.photo_ = CreateMaybeMessage<::cmd::HeatCamera::Photo>(GetArena());
  }
  return _impl_.cmd_.photo_;
}
inline ::cmd::HeatCamera::Photo* Root::mutable_photo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::Photo* _msg = _internal_mutable_photo();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.photo)
  return _msg;
}

// .cmd.HeatCamera.ZoomIn zoom_in = 10;
inline bool Root::has_zoom_in() const {
  return cmd_case() == kZoomIn;
}
inline bool Root::_internal_has_zoom_in() const {
  return cmd_case() == kZoomIn;
}
inline void Root::set_has_zoom_in() {
  _impl_._oneof_case_[0] = kZoomIn;
}
inline void Root::clear_zoom_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kZoomIn) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.zoom_in_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::ZoomIn* Root::release_zoom_in() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.zoom_in)
  if (cmd_case() == kZoomIn) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.zoom_in_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.zoom_in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::ZoomIn& Root::_internal_zoom_in() const {
  return cmd_case() == kZoomIn ? *_impl_.cmd_.zoom_in_ : reinterpret_cast<::cmd::HeatCamera::ZoomIn&>(::cmd::HeatCamera::_ZoomIn_default_instance_);
}
inline const ::cmd::HeatCamera::ZoomIn& Root::zoom_in() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.zoom_in)
  return _internal_zoom_in();
}
inline ::cmd::HeatCamera::ZoomIn* Root::unsafe_arena_release_zoom_in() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.zoom_in)
  if (cmd_case() == kZoomIn) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.zoom_in_;
    _impl_.cmd_.zoom_in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_zoom_in(::cmd::HeatCamera::ZoomIn* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_zoom_in();
    _impl_.cmd_.zoom_in_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.zoom_in)
}
inline ::cmd::HeatCamera::ZoomIn* Root::_internal_mutable_zoom_in() {
  if (cmd_case() != kZoomIn) {
    clear_cmd();
    set_has_zoom_in();
    _impl_.cmd_.zoom_in_ = CreateMaybeMessage<::cmd::HeatCamera::ZoomIn>(GetArena());
  }
  return _impl_.cmd_.zoom_in_;
}
inline ::cmd::HeatCamera::ZoomIn* Root::mutable_zoom_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::ZoomIn* _msg = _internal_mutable_zoom_in();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.zoom_in)
  return _msg;
}

// .cmd.HeatCamera.ZoomOut zoom_out = 11;
inline bool Root::has_zoom_out() const {
  return cmd_case() == kZoomOut;
}
inline bool Root::_internal_has_zoom_out() const {
  return cmd_case() == kZoomOut;
}
inline void Root::set_has_zoom_out() {
  _impl_._oneof_case_[0] = kZoomOut;
}
inline void Root::clear_zoom_out() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kZoomOut) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.zoom_out_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::ZoomOut* Root::release_zoom_out() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.zoom_out)
  if (cmd_case() == kZoomOut) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.zoom_out_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.zoom_out_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::ZoomOut& Root::_internal_zoom_out() const {
  return cmd_case() == kZoomOut ? *_impl_.cmd_.zoom_out_ : reinterpret_cast<::cmd::HeatCamera::ZoomOut&>(::cmd::HeatCamera::_ZoomOut_default_instance_);
}
inline const ::cmd::HeatCamera::ZoomOut& Root::zoom_out() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.zoom_out)
  return _internal_zoom_out();
}
inline ::cmd::HeatCamera::ZoomOut* Root::unsafe_arena_release_zoom_out() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.zoom_out)
  if (cmd_case() == kZoomOut) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.zoom_out_;
    _impl_.cmd_.zoom_out_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_zoom_out(::cmd::HeatCamera::ZoomOut* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_zoom_out();
    _impl_.cmd_.zoom_out_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.zoom_out)
}
inline ::cmd::HeatCamera::ZoomOut* Root::_internal_mutable_zoom_out() {
  if (cmd_case() != kZoomOut) {
    clear_cmd();
    set_has_zoom_out();
    _impl_.cmd_.zoom_out_ = CreateMaybeMessage<::cmd::HeatCamera::ZoomOut>(GetArena());
  }
  return _impl_.cmd_.zoom_out_;
}
inline ::cmd::HeatCamera::ZoomOut* Root::mutable_zoom_out() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::ZoomOut* _msg = _internal_mutable_zoom_out();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.zoom_out)
  return _msg;
}

// .cmd.HeatCamera.ZoomStop zoom_stop = 12;
inline bool Root::has_zoom_stop() const {
  return cmd_case() == kZoomStop;
}
inline bool Root::_internal_has_zoom_stop() const {
  return cmd_case() == kZoomStop;
}
inline void Root::set_has_zoom_stop() {
  _impl_._oneof_case_[0] = kZoomStop;
}
inline void Root::clear_zoom_stop() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kZoomStop) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.zoom_stop_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::ZoomStop* Root::release_zoom_stop() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.zoom_stop)
  if (cmd_case() == kZoomStop) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.zoom_stop_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.zoom_stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::ZoomStop& Root::_internal_zoom_stop() const {
  return cmd_case() == kZoomStop ? *_impl_.cmd_.zoom_stop_ : reinterpret_cast<::cmd::HeatCamera::ZoomStop&>(::cmd::HeatCamera::_ZoomStop_default_instance_);
}
inline const ::cmd::HeatCamera::ZoomStop& Root::zoom_stop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.zoom_stop)
  return _internal_zoom_stop();
}
inline ::cmd::HeatCamera::ZoomStop* Root::unsafe_arena_release_zoom_stop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.zoom_stop)
  if (cmd_case() == kZoomStop) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.zoom_stop_;
    _impl_.cmd_.zoom_stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_zoom_stop(::cmd::HeatCamera::ZoomStop* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_zoom_stop();
    _impl_.cmd_.zoom_stop_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.zoom_stop)
}
inline ::cmd::HeatCamera::ZoomStop* Root::_internal_mutable_zoom_stop() {
  if (cmd_case() != kZoomStop) {
    clear_cmd();
    set_has_zoom_stop();
    _impl_.cmd_.zoom_stop_ = CreateMaybeMessage<::cmd::HeatCamera::ZoomStop>(GetArena());
  }
  return _impl_.cmd_.zoom_stop_;
}
inline ::cmd::HeatCamera::ZoomStop* Root::mutable_zoom_stop() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::ZoomStop* _msg = _internal_mutable_zoom_stop();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.zoom_stop)
  return _msg;
}

// .cmd.HeatCamera.FocusIn focus_in = 13;
inline bool Root::has_focus_in() const {
  return cmd_case() == kFocusIn;
}
inline bool Root::_internal_has_focus_in() const {
  return cmd_case() == kFocusIn;
}
inline void Root::set_has_focus_in() {
  _impl_._oneof_case_[0] = kFocusIn;
}
inline void Root::clear_focus_in() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kFocusIn) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.focus_in_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::FocusIn* Root::release_focus_in() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.focus_in)
  if (cmd_case() == kFocusIn) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.focus_in_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.focus_in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::FocusIn& Root::_internal_focus_in() const {
  return cmd_case() == kFocusIn ? *_impl_.cmd_.focus_in_ : reinterpret_cast<::cmd::HeatCamera::FocusIn&>(::cmd::HeatCamera::_FocusIn_default_instance_);
}
inline const ::cmd::HeatCamera::FocusIn& Root::focus_in() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.focus_in)
  return _internal_focus_in();
}
inline ::cmd::HeatCamera::FocusIn* Root::unsafe_arena_release_focus_in() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.focus_in)
  if (cmd_case() == kFocusIn) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.focus_in_;
    _impl_.cmd_.focus_in_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_focus_in(::cmd::HeatCamera::FocusIn* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_focus_in();
    _impl_.cmd_.focus_in_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.focus_in)
}
inline ::cmd::HeatCamera::FocusIn* Root::_internal_mutable_focus_in() {
  if (cmd_case() != kFocusIn) {
    clear_cmd();
    set_has_focus_in();
    _impl_.cmd_.focus_in_ = CreateMaybeMessage<::cmd::HeatCamera::FocusIn>(GetArena());
  }
  return _impl_.cmd_.focus_in_;
}
inline ::cmd::HeatCamera::FocusIn* Root::mutable_focus_in() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::FocusIn* _msg = _internal_mutable_focus_in();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.focus_in)
  return _msg;
}

// .cmd.HeatCamera.FocusOut focus_out = 14;
inline bool Root::has_focus_out() const {
  return cmd_case() == kFocusOut;
}
inline bool Root::_internal_has_focus_out() const {
  return cmd_case() == kFocusOut;
}
inline void Root::set_has_focus_out() {
  _impl_._oneof_case_[0] = kFocusOut;
}
inline void Root::clear_focus_out() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kFocusOut) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.focus_out_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::FocusOut* Root::release_focus_out() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.focus_out)
  if (cmd_case() == kFocusOut) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.focus_out_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.focus_out_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::FocusOut& Root::_internal_focus_out() const {
  return cmd_case() == kFocusOut ? *_impl_.cmd_.focus_out_ : reinterpret_cast<::cmd::HeatCamera::FocusOut&>(::cmd::HeatCamera::_FocusOut_default_instance_);
}
inline const ::cmd::HeatCamera::FocusOut& Root::focus_out() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.focus_out)
  return _internal_focus_out();
}
inline ::cmd::HeatCamera::FocusOut* Root::unsafe_arena_release_focus_out() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.focus_out)
  if (cmd_case() == kFocusOut) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.focus_out_;
    _impl_.cmd_.focus_out_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_focus_out(::cmd::HeatCamera::FocusOut* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_focus_out();
    _impl_.cmd_.focus_out_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.focus_out)
}
inline ::cmd::HeatCamera::FocusOut* Root::_internal_mutable_focus_out() {
  if (cmd_case() != kFocusOut) {
    clear_cmd();
    set_has_focus_out();
    _impl_.cmd_.focus_out_ = CreateMaybeMessage<::cmd::HeatCamera::FocusOut>(GetArena());
  }
  return _impl_.cmd_.focus_out_;
}
inline ::cmd::HeatCamera::FocusOut* Root::mutable_focus_out() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::FocusOut* _msg = _internal_mutable_focus_out();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.focus_out)
  return _msg;
}

// .cmd.HeatCamera.FocusStop focus_stop = 15;
inline bool Root::has_focus_stop() const {
  return cmd_case() == kFocusStop;
}
inline bool Root::_internal_has_focus_stop() const {
  return cmd_case() == kFocusStop;
}
inline void Root::set_has_focus_stop() {
  _impl_._oneof_case_[0] = kFocusStop;
}
inline void Root::clear_focus_stop() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kFocusStop) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.focus_stop_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::FocusStop* Root::release_focus_stop() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.focus_stop)
  if (cmd_case() == kFocusStop) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.focus_stop_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.focus_stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::FocusStop& Root::_internal_focus_stop() const {
  return cmd_case() == kFocusStop ? *_impl_.cmd_.focus_stop_ : reinterpret_cast<::cmd::HeatCamera::FocusStop&>(::cmd::HeatCamera::_FocusStop_default_instance_);
}
inline const ::cmd::HeatCamera::FocusStop& Root::focus_stop() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.focus_stop)
  return _internal_focus_stop();
}
inline ::cmd::HeatCamera::FocusStop* Root::unsafe_arena_release_focus_stop() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.focus_stop)
  if (cmd_case() == kFocusStop) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.focus_stop_;
    _impl_.cmd_.focus_stop_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_focus_stop(::cmd::HeatCamera::FocusStop* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_focus_stop();
    _impl_.cmd_.focus_stop_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.focus_stop)
}
inline ::cmd::HeatCamera::FocusStop* Root::_internal_mutable_focus_stop() {
  if (cmd_case() != kFocusStop) {
    clear_cmd();
    set_has_focus_stop();
    _impl_.cmd_.focus_stop_ = CreateMaybeMessage<::cmd::HeatCamera::FocusStop>(GetArena());
  }
  return _impl_.cmd_.focus_stop_;
}
inline ::cmd::HeatCamera::FocusStop* Root::mutable_focus_stop() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::FocusStop* _msg = _internal_mutable_focus_stop();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.focus_stop)
  return _msg;
}

// .cmd.HeatCamera.Calibrate calibrate = 16;
inline bool Root::has_calibrate() const {
  return cmd_case() == kCalibrate;
}
inline bool Root::_internal_has_calibrate() const {
  return cmd_case() == kCalibrate;
}
inline void Root::set_has_calibrate() {
  _impl_._oneof_case_[0] = kCalibrate;
}
inline void Root::clear_calibrate() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kCalibrate) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.calibrate_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::Calibrate* Root::release_calibrate() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.calibrate)
  if (cmd_case() == kCalibrate) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.calibrate_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.calibrate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::Calibrate& Root::_internal_calibrate() const {
  return cmd_case() == kCalibrate ? *_impl_.cmd_.calibrate_ : reinterpret_cast<::cmd::HeatCamera::Calibrate&>(::cmd::HeatCamera::_Calibrate_default_instance_);
}
inline const ::cmd::HeatCamera::Calibrate& Root::calibrate() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.calibrate)
  return _internal_calibrate();
}
inline ::cmd::HeatCamera::Calibrate* Root::unsafe_arena_release_calibrate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.calibrate)
  if (cmd_case() == kCalibrate) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.calibrate_;
    _impl_.cmd_.calibrate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_calibrate(::cmd::HeatCamera::Calibrate* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_calibrate();
    _impl_.cmd_.calibrate_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.calibrate)
}
inline ::cmd::HeatCamera::Calibrate* Root::_internal_mutable_calibrate() {
  if (cmd_case() != kCalibrate) {
    clear_cmd();
    set_has_calibrate();
    _impl_.cmd_.calibrate_ = CreateMaybeMessage<::cmd::HeatCamera::Calibrate>(GetArena());
  }
  return _impl_.cmd_.calibrate_;
}
inline ::cmd::HeatCamera::Calibrate* Root::mutable_calibrate() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::Calibrate* _msg = _internal_mutable_calibrate();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.calibrate)
  return _msg;
}

// .cmd.HeatCamera.SetDDELevel set_dde_level = 17;
inline bool Root::has_set_dde_level() const {
  return cmd_case() == kSetDdeLevel;
}
inline bool Root::_internal_has_set_dde_level() const {
  return cmd_case() == kSetDdeLevel;
}
inline void Root::set_has_set_dde_level() {
  _impl_._oneof_case_[0] = kSetDdeLevel;
}
inline void Root::clear_set_dde_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kSetDdeLevel) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.set_dde_level_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::SetDDELevel* Root::release_set_dde_level() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.set_dde_level)
  if (cmd_case() == kSetDdeLevel) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_dde_level_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.set_dde_level_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::SetDDELevel& Root::_internal_set_dde_level() const {
  return cmd_case() == kSetDdeLevel ? *_impl_.cmd_.set_dde_level_ : reinterpret_cast<::cmd::HeatCamera::SetDDELevel&>(::cmd::HeatCamera::_SetDDELevel_default_instance_);
}
inline const ::cmd::HeatCamera::SetDDELevel& Root::set_dde_level() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.set_dde_level)
  return _internal_set_dde_level();
}
inline ::cmd::HeatCamera::SetDDELevel* Root::unsafe_arena_release_set_dde_level() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.set_dde_level)
  if (cmd_case() == kSetDdeLevel) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_dde_level_;
    _impl_.cmd_.set_dde_level_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_set_dde_level(::cmd::HeatCamera::SetDDELevel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_set_dde_level();
    _impl_.cmd_.set_dde_level_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.set_dde_level)
}
inline ::cmd::HeatCamera::SetDDELevel* Root::_internal_mutable_set_dde_level() {
  if (cmd_case() != kSetDdeLevel) {
    clear_cmd();
    set_has_set_dde_level();
    _impl_.cmd_.set_dde_level_ = CreateMaybeMessage<::cmd::HeatCamera::SetDDELevel>(GetArena());
  }
  return _impl_.cmd_.set_dde_level_;
}
inline ::cmd::HeatCamera::SetDDELevel* Root::mutable_set_dde_level() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::SetDDELevel* _msg = _internal_mutable_set_dde_level();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.set_dde_level)
  return _msg;
}

// .cmd.HeatCamera.EnableDDE enable_dde = 18;
inline bool Root::has_enable_dde() const {
  return cmd_case() == kEnableDde;
}
inline bool Root::_internal_has_enable_dde() const {
  return cmd_case() == kEnableDde;
}
inline void Root::set_has_enable_dde() {
  _impl_._oneof_case_[0] = kEnableDde;
}
inline void Root::clear_enable_dde() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kEnableDde) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.enable_dde_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::EnableDDE* Root::release_enable_dde() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.enable_dde)
  if (cmd_case() == kEnableDde) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.enable_dde_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.enable_dde_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::EnableDDE& Root::_internal_enable_dde() const {
  return cmd_case() == kEnableDde ? *_impl_.cmd_.enable_dde_ : reinterpret_cast<::cmd::HeatCamera::EnableDDE&>(::cmd::HeatCamera::_EnableDDE_default_instance_);
}
inline const ::cmd::HeatCamera::EnableDDE& Root::enable_dde() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.enable_dde)
  return _internal_enable_dde();
}
inline ::cmd::HeatCamera::EnableDDE* Root::unsafe_arena_release_enable_dde() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.enable_dde)
  if (cmd_case() == kEnableDde) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.enable_dde_;
    _impl_.cmd_.enable_dde_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_enable_dde(::cmd::HeatCamera::EnableDDE* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_enable_dde();
    _impl_.cmd_.enable_dde_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.enable_dde)
}
inline ::cmd::HeatCamera::EnableDDE* Root::_internal_mutable_enable_dde() {
  if (cmd_case() != kEnableDde) {
    clear_cmd();
    set_has_enable_dde();
    _impl_.cmd_.enable_dde_ = CreateMaybeMessage<::cmd::HeatCamera::EnableDDE>(GetArena());
  }
  return _impl_.cmd_.enable_dde_;
}
inline ::cmd::HeatCamera::EnableDDE* Root::mutable_enable_dde() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::EnableDDE* _msg = _internal_mutable_enable_dde();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.enable_dde)
  return _msg;
}

// .cmd.HeatCamera.DisableDDE disable_dde = 19;
inline bool Root::has_disable_dde() const {
  return cmd_case() == kDisableDde;
}
inline bool Root::_internal_has_disable_dde() const {
  return cmd_case() == kDisableDde;
}
inline void Root::set_has_disable_dde() {
  _impl_._oneof_case_[0] = kDisableDde;
}
inline void Root::clear_disable_dde() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kDisableDde) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.disable_dde_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::DisableDDE* Root::release_disable_dde() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.disable_dde)
  if (cmd_case() == kDisableDde) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.disable_dde_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.disable_dde_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::DisableDDE& Root::_internal_disable_dde() const {
  return cmd_case() == kDisableDde ? *_impl_.cmd_.disable_dde_ : reinterpret_cast<::cmd::HeatCamera::DisableDDE&>(::cmd::HeatCamera::_DisableDDE_default_instance_);
}
inline const ::cmd::HeatCamera::DisableDDE& Root::disable_dde() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.disable_dde)
  return _internal_disable_dde();
}
inline ::cmd::HeatCamera::DisableDDE* Root::unsafe_arena_release_disable_dde() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.disable_dde)
  if (cmd_case() == kDisableDde) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.disable_dde_;
    _impl_.cmd_.disable_dde_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_disable_dde(::cmd::HeatCamera::DisableDDE* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_disable_dde();
    _impl_.cmd_.disable_dde_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.disable_dde)
}
inline ::cmd::HeatCamera::DisableDDE* Root::_internal_mutable_disable_dde() {
  if (cmd_case() != kDisableDde) {
    clear_cmd();
    set_has_disable_dde();
    _impl_.cmd_.disable_dde_ = CreateMaybeMessage<::cmd::HeatCamera::DisableDDE>(GetArena());
  }
  return _impl_.cmd_.disable_dde_;
}
inline ::cmd::HeatCamera::DisableDDE* Root::mutable_disable_dde() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::DisableDDE* _msg = _internal_mutable_disable_dde();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.disable_dde)
  return _msg;
}

// .cmd.HeatCamera.SetAutoFocus set_auto_focus = 20;
inline bool Root::has_set_auto_focus() const {
  return cmd_case() == kSetAutoFocus;
}
inline bool Root::_internal_has_set_auto_focus() const {
  return cmd_case() == kSetAutoFocus;
}
inline void Root::set_has_set_auto_focus() {
  _impl_._oneof_case_[0] = kSetAutoFocus;
}
inline void Root::clear_set_auto_focus() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kSetAutoFocus) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.set_auto_focus_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::SetAutoFocus* Root::release_set_auto_focus() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.set_auto_focus)
  if (cmd_case() == kSetAutoFocus) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_auto_focus_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.set_auto_focus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::SetAutoFocus& Root::_internal_set_auto_focus() const {
  return cmd_case() == kSetAutoFocus ? *_impl_.cmd_.set_auto_focus_ : reinterpret_cast<::cmd::HeatCamera::SetAutoFocus&>(::cmd::HeatCamera::_SetAutoFocus_default_instance_);
}
inline const ::cmd::HeatCamera::SetAutoFocus& Root::set_auto_focus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.set_auto_focus)
  return _internal_set_auto_focus();
}
inline ::cmd::HeatCamera::SetAutoFocus* Root::unsafe_arena_release_set_auto_focus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.set_auto_focus)
  if (cmd_case() == kSetAutoFocus) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_auto_focus_;
    _impl_.cmd_.set_auto_focus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_set_auto_focus(::cmd::HeatCamera::SetAutoFocus* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_set_auto_focus();
    _impl_.cmd_.set_auto_focus_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.set_auto_focus)
}
inline ::cmd::HeatCamera::SetAutoFocus* Root::_internal_mutable_set_auto_focus() {
  if (cmd_case() != kSetAutoFocus) {
    clear_cmd();
    set_has_set_auto_focus();
    _impl_.cmd_.set_auto_focus_ = CreateMaybeMessage<::cmd::HeatCamera::SetAutoFocus>(GetArena());
  }
  return _impl_.cmd_.set_auto_focus_;
}
inline ::cmd::HeatCamera::SetAutoFocus* Root::mutable_set_auto_focus() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::SetAutoFocus* _msg = _internal_mutable_set_auto_focus();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.set_auto_focus)
  return _msg;
}

// .cmd.HeatCamera.FocusStepPlus focus_step_plus = 21;
inline bool Root::has_focus_step_plus() const {
  return cmd_case() == kFocusStepPlus;
}
inline bool Root::_internal_has_focus_step_plus() const {
  return cmd_case() == kFocusStepPlus;
}
inline void Root::set_has_focus_step_plus() {
  _impl_._oneof_case_[0] = kFocusStepPlus;
}
inline void Root::clear_focus_step_plus() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kFocusStepPlus) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.focus_step_plus_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::FocusStepPlus* Root::release_focus_step_plus() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.focus_step_plus)
  if (cmd_case() == kFocusStepPlus) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.focus_step_plus_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.focus_step_plus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::FocusStepPlus& Root::_internal_focus_step_plus() const {
  return cmd_case() == kFocusStepPlus ? *_impl_.cmd_.focus_step_plus_ : reinterpret_cast<::cmd::HeatCamera::FocusStepPlus&>(::cmd::HeatCamera::_FocusStepPlus_default_instance_);
}
inline const ::cmd::HeatCamera::FocusStepPlus& Root::focus_step_plus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.focus_step_plus)
  return _internal_focus_step_plus();
}
inline ::cmd::HeatCamera::FocusStepPlus* Root::unsafe_arena_release_focus_step_plus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.focus_step_plus)
  if (cmd_case() == kFocusStepPlus) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.focus_step_plus_;
    _impl_.cmd_.focus_step_plus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_focus_step_plus(::cmd::HeatCamera::FocusStepPlus* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_focus_step_plus();
    _impl_.cmd_.focus_step_plus_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.focus_step_plus)
}
inline ::cmd::HeatCamera::FocusStepPlus* Root::_internal_mutable_focus_step_plus() {
  if (cmd_case() != kFocusStepPlus) {
    clear_cmd();
    set_has_focus_step_plus();
    _impl_.cmd_.focus_step_plus_ = CreateMaybeMessage<::cmd::HeatCamera::FocusStepPlus>(GetArena());
  }
  return _impl_.cmd_.focus_step_plus_;
}
inline ::cmd::HeatCamera::FocusStepPlus* Root::mutable_focus_step_plus() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::FocusStepPlus* _msg = _internal_mutable_focus_step_plus();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.focus_step_plus)
  return _msg;
}

// .cmd.HeatCamera.FocusStepMinus focus_step_minus = 22;
inline bool Root::has_focus_step_minus() const {
  return cmd_case() == kFocusStepMinus;
}
inline bool Root::_internal_has_focus_step_minus() const {
  return cmd_case() == kFocusStepMinus;
}
inline void Root::set_has_focus_step_minus() {
  _impl_._oneof_case_[0] = kFocusStepMinus;
}
inline void Root::clear_focus_step_minus() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kFocusStepMinus) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.focus_step_minus_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::FocusStepMinus* Root::release_focus_step_minus() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.focus_step_minus)
  if (cmd_case() == kFocusStepMinus) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.focus_step_minus_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.focus_step_minus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::FocusStepMinus& Root::_internal_focus_step_minus() const {
  return cmd_case() == kFocusStepMinus ? *_impl_.cmd_.focus_step_minus_ : reinterpret_cast<::cmd::HeatCamera::FocusStepMinus&>(::cmd::HeatCamera::_FocusStepMinus_default_instance_);
}
inline const ::cmd::HeatCamera::FocusStepMinus& Root::focus_step_minus() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.focus_step_minus)
  return _internal_focus_step_minus();
}
inline ::cmd::HeatCamera::FocusStepMinus* Root::unsafe_arena_release_focus_step_minus() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.focus_step_minus)
  if (cmd_case() == kFocusStepMinus) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.focus_step_minus_;
    _impl_.cmd_.focus_step_minus_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_focus_step_minus(::cmd::HeatCamera::FocusStepMinus* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_focus_step_minus();
    _impl_.cmd_.focus_step_minus_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.focus_step_minus)
}
inline ::cmd::HeatCamera::FocusStepMinus* Root::_internal_mutable_focus_step_minus() {
  if (cmd_case() != kFocusStepMinus) {
    clear_cmd();
    set_has_focus_step_minus();
    _impl_.cmd_.focus_step_minus_ = CreateMaybeMessage<::cmd::HeatCamera::FocusStepMinus>(GetArena());
  }
  return _impl_.cmd_.focus_step_minus_;
}
inline ::cmd::HeatCamera::FocusStepMinus* Root::mutable_focus_step_minus() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::FocusStepMinus* _msg = _internal_mutable_focus_step_minus();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.focus_step_minus)
  return _msg;
}

// .cmd.HeatCamera.SetFxMode set_fx_mode = 23;
inline bool Root::has_set_fx_mode() const {
  return cmd_case() == kSetFxMode;
}
inline bool Root::_internal_has_set_fx_mode() const {
  return cmd_case() == kSetFxMode;
}
inline void Root::set_has_set_fx_mode() {
  _impl_._oneof_case_[0] = kSetFxMode;
}
inline void Root::clear_set_fx_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kSetFxMode) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.set_fx_mode_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::SetFxMode* Root::release_set_fx_mode() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.set_fx_mode)
  if (cmd_case() == kSetFxMode) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_fx_mode_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.set_fx_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::SetFxMode& Root::_internal_set_fx_mode() const {
  return cmd_case() == kSetFxMode ? *_impl_.cmd_.set_fx_mode_ : reinterpret_cast<::cmd::HeatCamera::SetFxMode&>(::cmd::HeatCamera::_SetFxMode_default_instance_);
}
inline const ::cmd::HeatCamera::SetFxMode& Root::set_fx_mode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.set_fx_mode)
  return _internal_set_fx_mode();
}
inline ::cmd::HeatCamera::SetFxMode* Root::unsafe_arena_release_set_fx_mode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.set_fx_mode)
  if (cmd_case() == kSetFxMode) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_fx_mode_;
    _impl_.cmd_.set_fx_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_set_fx_mode(::cmd::HeatCamera::SetFxMode* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_set_fx_mode();
    _impl_.cmd_.set_fx_mode_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.set_fx_mode)
}
inline ::cmd::HeatCamera::SetFxMode* Root::_internal_mutable_set_fx_mode() {
  if (cmd_case() != kSetFxMode) {
    clear_cmd();
    set_has_set_fx_mode();
    _impl_.cmd_.set_fx_mode_ = CreateMaybeMessage<::cmd::HeatCamera::SetFxMode>(GetArena());
  }
  return _impl_.cmd_.set_fx_mode_;
}
inline ::cmd::HeatCamera::SetFxMode* Root::mutable_set_fx_mode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::SetFxMode* _msg = _internal_mutable_set_fx_mode();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.set_fx_mode)
  return _msg;
}

// .cmd.HeatCamera.NextFxMode next_fx_mode = 24;
inline bool Root::has_next_fx_mode() const {
  return cmd_case() == kNextFxMode;
}
inline bool Root::_internal_has_next_fx_mode() const {
  return cmd_case() == kNextFxMode;
}
inline void Root::set_has_next_fx_mode() {
  _impl_._oneof_case_[0] = kNextFxMode;
}
inline void Root::clear_next_fx_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kNextFxMode) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.next_fx_mode_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::NextFxMode* Root::release_next_fx_mode() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.next_fx_mode)
  if (cmd_case() == kNextFxMode) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.next_fx_mode_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.next_fx_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::NextFxMode& Root::_internal_next_fx_mode() const {
  return cmd_case() == kNextFxMode ? *_impl_.cmd_.next_fx_mode_ : reinterpret_cast<::cmd::HeatCamera::NextFxMode&>(::cmd::HeatCamera::_NextFxMode_default_instance_);
}
inline const ::cmd::HeatCamera::NextFxMode& Root::next_fx_mode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.next_fx_mode)
  return _internal_next_fx_mode();
}
inline ::cmd::HeatCamera::NextFxMode* Root::unsafe_arena_release_next_fx_mode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.next_fx_mode)
  if (cmd_case() == kNextFxMode) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.next_fx_mode_;
    _impl_.cmd_.next_fx_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_next_fx_mode(::cmd::HeatCamera::NextFxMode* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_next_fx_mode();
    _impl_.cmd_.next_fx_mode_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.next_fx_mode)
}
inline ::cmd::HeatCamera::NextFxMode* Root::_internal_mutable_next_fx_mode() {
  if (cmd_case() != kNextFxMode) {
    clear_cmd();
    set_has_next_fx_mode();
    _impl_.cmd_.next_fx_mode_ = CreateMaybeMessage<::cmd::HeatCamera::NextFxMode>(GetArena());
  }
  return _impl_.cmd_.next_fx_mode_;
}
inline ::cmd::HeatCamera::NextFxMode* Root::mutable_next_fx_mode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::NextFxMode* _msg = _internal_mutable_next_fx_mode();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.next_fx_mode)
  return _msg;
}

// .cmd.HeatCamera.PrevFxMode prev_fx_mode = 25;
inline bool Root::has_prev_fx_mode() const {
  return cmd_case() == kPrevFxMode;
}
inline bool Root::_internal_has_prev_fx_mode() const {
  return cmd_case() == kPrevFxMode;
}
inline void Root::set_has_prev_fx_mode() {
  _impl_._oneof_case_[0] = kPrevFxMode;
}
inline void Root::clear_prev_fx_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kPrevFxMode) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.prev_fx_mode_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::PrevFxMode* Root::release_prev_fx_mode() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.prev_fx_mode)
  if (cmd_case() == kPrevFxMode) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.prev_fx_mode_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.prev_fx_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::PrevFxMode& Root::_internal_prev_fx_mode() const {
  return cmd_case() == kPrevFxMode ? *_impl_.cmd_.prev_fx_mode_ : reinterpret_cast<::cmd::HeatCamera::PrevFxMode&>(::cmd::HeatCamera::_PrevFxMode_default_instance_);
}
inline const ::cmd::HeatCamera::PrevFxMode& Root::prev_fx_mode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.prev_fx_mode)
  return _internal_prev_fx_mode();
}
inline ::cmd::HeatCamera::PrevFxMode* Root::unsafe_arena_release_prev_fx_mode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.prev_fx_mode)
  if (cmd_case() == kPrevFxMode) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.prev_fx_mode_;
    _impl_.cmd_.prev_fx_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_prev_fx_mode(::cmd::HeatCamera::PrevFxMode* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_prev_fx_mode();
    _impl_.cmd_.prev_fx_mode_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.prev_fx_mode)
}
inline ::cmd::HeatCamera::PrevFxMode* Root::_internal_mutable_prev_fx_mode() {
  if (cmd_case() != kPrevFxMode) {
    clear_cmd();
    set_has_prev_fx_mode();
    _impl_.cmd_.prev_fx_mode_ = CreateMaybeMessage<::cmd::HeatCamera::PrevFxMode>(GetArena());
  }
  return _impl_.cmd_.prev_fx_mode_;
}
inline ::cmd::HeatCamera::PrevFxMode* Root::mutable_prev_fx_mode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::PrevFxMode* _msg = _internal_mutable_prev_fx_mode();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.prev_fx_mode)
  return _msg;
}

// .cmd.HeatCamera.GetMeteo get_meteo = 26;
inline bool Root::has_get_meteo() const {
  return cmd_case() == kGetMeteo;
}
inline bool Root::_internal_has_get_meteo() const {
  return cmd_case() == kGetMeteo;
}
inline void Root::set_has_get_meteo() {
  _impl_._oneof_case_[0] = kGetMeteo;
}
inline void Root::clear_get_meteo() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kGetMeteo) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.get_meteo_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::GetMeteo* Root::release_get_meteo() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.get_meteo)
  if (cmd_case() == kGetMeteo) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.get_meteo_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.get_meteo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::GetMeteo& Root::_internal_get_meteo() const {
  return cmd_case() == kGetMeteo ? *_impl_.cmd_.get_meteo_ : reinterpret_cast<::cmd::HeatCamera::GetMeteo&>(::cmd::HeatCamera::_GetMeteo_default_instance_);
}
inline const ::cmd::HeatCamera::GetMeteo& Root::get_meteo() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.get_meteo)
  return _internal_get_meteo();
}
inline ::cmd::HeatCamera::GetMeteo* Root::unsafe_arena_release_get_meteo() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.get_meteo)
  if (cmd_case() == kGetMeteo) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.get_meteo_;
    _impl_.cmd_.get_meteo_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_get_meteo(::cmd::HeatCamera::GetMeteo* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_get_meteo();
    _impl_.cmd_.get_meteo_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.get_meteo)
}
inline ::cmd::HeatCamera::GetMeteo* Root::_internal_mutable_get_meteo() {
  if (cmd_case() != kGetMeteo) {
    clear_cmd();
    set_has_get_meteo();
    _impl_.cmd_.get_meteo_ = CreateMaybeMessage<::cmd::HeatCamera::GetMeteo>(GetArena());
  }
  return _impl_.cmd_.get_meteo_;
}
inline ::cmd::HeatCamera::GetMeteo* Root::mutable_get_meteo() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::GetMeteo* _msg = _internal_mutable_get_meteo();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.get_meteo)
  return _msg;
}

// .cmd.HeatCamera.ShiftDDE shift_dde = 27;
inline bool Root::has_shift_dde() const {
  return cmd_case() == kShiftDde;
}
inline bool Root::_internal_has_shift_dde() const {
  return cmd_case() == kShiftDde;
}
inline void Root::set_has_shift_dde() {
  _impl_._oneof_case_[0] = kShiftDde;
}
inline void Root::clear_shift_dde() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kShiftDde) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.shift_dde_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::ShiftDDE* Root::release_shift_dde() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.shift_dde)
  if (cmd_case() == kShiftDde) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.shift_dde_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.shift_dde_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::ShiftDDE& Root::_internal_shift_dde() const {
  return cmd_case() == kShiftDde ? *_impl_.cmd_.shift_dde_ : reinterpret_cast<::cmd::HeatCamera::ShiftDDE&>(::cmd::HeatCamera::_ShiftDDE_default_instance_);
}
inline const ::cmd::HeatCamera::ShiftDDE& Root::shift_dde() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.shift_dde)
  return _internal_shift_dde();
}
inline ::cmd::HeatCamera::ShiftDDE* Root::unsafe_arena_release_shift_dde() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.shift_dde)
  if (cmd_case() == kShiftDde) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.shift_dde_;
    _impl_.cmd_.shift_dde_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_shift_dde(::cmd::HeatCamera::ShiftDDE* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_shift_dde();
    _impl_.cmd_.shift_dde_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.shift_dde)
}
inline ::cmd::HeatCamera::ShiftDDE* Root::_internal_mutable_shift_dde() {
  if (cmd_case() != kShiftDde) {
    clear_cmd();
    set_has_shift_dde();
    _impl_.cmd_.shift_dde_ = CreateMaybeMessage<::cmd::HeatCamera::ShiftDDE>(GetArena());
  }
  return _impl_.cmd_.shift_dde_;
}
inline ::cmd::HeatCamera::ShiftDDE* Root::mutable_shift_dde() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::ShiftDDE* _msg = _internal_mutable_shift_dde();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.shift_dde)
  return _msg;
}

// .cmd.HeatCamera.RefreshFxMode refresh_fx_mode = 28;
inline bool Root::has_refresh_fx_mode() const {
  return cmd_case() == kRefreshFxMode;
}
inline bool Root::_internal_has_refresh_fx_mode() const {
  return cmd_case() == kRefreshFxMode;
}
inline void Root::set_has_refresh_fx_mode() {
  _impl_._oneof_case_[0] = kRefreshFxMode;
}
inline void Root::clear_refresh_fx_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kRefreshFxMode) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.refresh_fx_mode_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::RefreshFxMode* Root::release_refresh_fx_mode() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.refresh_fx_mode)
  if (cmd_case() == kRefreshFxMode) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.refresh_fx_mode_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.refresh_fx_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::RefreshFxMode& Root::_internal_refresh_fx_mode() const {
  return cmd_case() == kRefreshFxMode ? *_impl_.cmd_.refresh_fx_mode_ : reinterpret_cast<::cmd::HeatCamera::RefreshFxMode&>(::cmd::HeatCamera::_RefreshFxMode_default_instance_);
}
inline const ::cmd::HeatCamera::RefreshFxMode& Root::refresh_fx_mode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.refresh_fx_mode)
  return _internal_refresh_fx_mode();
}
inline ::cmd::HeatCamera::RefreshFxMode* Root::unsafe_arena_release_refresh_fx_mode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.refresh_fx_mode)
  if (cmd_case() == kRefreshFxMode) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.refresh_fx_mode_;
    _impl_.cmd_.refresh_fx_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_refresh_fx_mode(::cmd::HeatCamera::RefreshFxMode* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_refresh_fx_mode();
    _impl_.cmd_.refresh_fx_mode_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.refresh_fx_mode)
}
inline ::cmd::HeatCamera::RefreshFxMode* Root::_internal_mutable_refresh_fx_mode() {
  if (cmd_case() != kRefreshFxMode) {
    clear_cmd();
    set_has_refresh_fx_mode();
    _impl_.cmd_.refresh_fx_mode_ = CreateMaybeMessage<::cmd::HeatCamera::RefreshFxMode>(GetArena());
  }
  return _impl_.cmd_.refresh_fx_mode_;
}
inline ::cmd::HeatCamera::RefreshFxMode* Root::mutable_refresh_fx_mode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::RefreshFxMode* _msg = _internal_mutable_refresh_fx_mode();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.refresh_fx_mode)
  return _msg;
}

// .cmd.HeatCamera.ResetZoom reset_zoom = 29;
inline bool Root::has_reset_zoom() const {
  return cmd_case() == kResetZoom;
}
inline bool Root::_internal_has_reset_zoom() const {
  return cmd_case() == kResetZoom;
}
inline void Root::set_has_reset_zoom() {
  _impl_._oneof_case_[0] = kResetZoom;
}
inline void Root::clear_reset_zoom() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kResetZoom) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.reset_zoom_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::ResetZoom* Root::release_reset_zoom() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.reset_zoom)
  if (cmd_case() == kResetZoom) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.reset_zoom_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.reset_zoom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::ResetZoom& Root::_internal_reset_zoom() const {
  return cmd_case() == kResetZoom ? *_impl_.cmd_.reset_zoom_ : reinterpret_cast<::cmd::HeatCamera::ResetZoom&>(::cmd::HeatCamera::_ResetZoom_default_instance_);
}
inline const ::cmd::HeatCamera::ResetZoom& Root::reset_zoom() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.reset_zoom)
  return _internal_reset_zoom();
}
inline ::cmd::HeatCamera::ResetZoom* Root::unsafe_arena_release_reset_zoom() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.reset_zoom)
  if (cmd_case() == kResetZoom) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.reset_zoom_;
    _impl_.cmd_.reset_zoom_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_reset_zoom(::cmd::HeatCamera::ResetZoom* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_reset_zoom();
    _impl_.cmd_.reset_zoom_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.reset_zoom)
}
inline ::cmd::HeatCamera::ResetZoom* Root::_internal_mutable_reset_zoom() {
  if (cmd_case() != kResetZoom) {
    clear_cmd();
    set_has_reset_zoom();
    _impl_.cmd_.reset_zoom_ = CreateMaybeMessage<::cmd::HeatCamera::ResetZoom>(GetArena());
  }
  return _impl_.cmd_.reset_zoom_;
}
inline ::cmd::HeatCamera::ResetZoom* Root::mutable_reset_zoom() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::ResetZoom* _msg = _internal_mutable_reset_zoom();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.reset_zoom)
  return _msg;
}

// .cmd.HeatCamera.SaveToTable save_to_table = 30;
inline bool Root::has_save_to_table() const {
  return cmd_case() == kSaveToTable;
}
inline bool Root::_internal_has_save_to_table() const {
  return cmd_case() == kSaveToTable;
}
inline void Root::set_has_save_to_table() {
  _impl_._oneof_case_[0] = kSaveToTable;
}
inline void Root::clear_save_to_table() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kSaveToTable) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.save_to_table_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::SaveToTable* Root::release_save_to_table() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.save_to_table)
  if (cmd_case() == kSaveToTable) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.save_to_table_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.save_to_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::SaveToTable& Root::_internal_save_to_table() const {
  return cmd_case() == kSaveToTable ? *_impl_.cmd_.save_to_table_ : reinterpret_cast<::cmd::HeatCamera::SaveToTable&>(::cmd::HeatCamera::_SaveToTable_default_instance_);
}
inline const ::cmd::HeatCamera::SaveToTable& Root::save_to_table() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.save_to_table)
  return _internal_save_to_table();
}
inline ::cmd::HeatCamera::SaveToTable* Root::unsafe_arena_release_save_to_table() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.save_to_table)
  if (cmd_case() == kSaveToTable) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.save_to_table_;
    _impl_.cmd_.save_to_table_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_save_to_table(::cmd::HeatCamera::SaveToTable* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_save_to_table();
    _impl_.cmd_.save_to_table_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.save_to_table)
}
inline ::cmd::HeatCamera::SaveToTable* Root::_internal_mutable_save_to_table() {
  if (cmd_case() != kSaveToTable) {
    clear_cmd();
    set_has_save_to_table();
    _impl_.cmd_.save_to_table_ = CreateMaybeMessage<::cmd::HeatCamera::SaveToTable>(GetArena());
  }
  return _impl_.cmd_.save_to_table_;
}
inline ::cmd::HeatCamera::SaveToTable* Root::mutable_save_to_table() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::SaveToTable* _msg = _internal_mutable_save_to_table();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.save_to_table)
  return _msg;
}

// .cmd.HeatCamera.SetCalibMode set_calib_mode = 31;
inline bool Root::has_set_calib_mode() const {
  return cmd_case() == kSetCalibMode;
}
inline bool Root::_internal_has_set_calib_mode() const {
  return cmd_case() == kSetCalibMode;
}
inline void Root::set_has_set_calib_mode() {
  _impl_._oneof_case_[0] = kSetCalibMode;
}
inline void Root::clear_set_calib_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kSetCalibMode) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.set_calib_mode_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::SetCalibMode* Root::release_set_calib_mode() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.set_calib_mode)
  if (cmd_case() == kSetCalibMode) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_calib_mode_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.set_calib_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::SetCalibMode& Root::_internal_set_calib_mode() const {
  return cmd_case() == kSetCalibMode ? *_impl_.cmd_.set_calib_mode_ : reinterpret_cast<::cmd::HeatCamera::SetCalibMode&>(::cmd::HeatCamera::_SetCalibMode_default_instance_);
}
inline const ::cmd::HeatCamera::SetCalibMode& Root::set_calib_mode() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.set_calib_mode)
  return _internal_set_calib_mode();
}
inline ::cmd::HeatCamera::SetCalibMode* Root::unsafe_arena_release_set_calib_mode() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.set_calib_mode)
  if (cmd_case() == kSetCalibMode) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_calib_mode_;
    _impl_.cmd_.set_calib_mode_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_set_calib_mode(::cmd::HeatCamera::SetCalibMode* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_set_calib_mode();
    _impl_.cmd_.set_calib_mode_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.set_calib_mode)
}
inline ::cmd::HeatCamera::SetCalibMode* Root::_internal_mutable_set_calib_mode() {
  if (cmd_case() != kSetCalibMode) {
    clear_cmd();
    set_has_set_calib_mode();
    _impl_.cmd_.set_calib_mode_ = CreateMaybeMessage<::cmd::HeatCamera::SetCalibMode>(GetArena());
  }
  return _impl_.cmd_.set_calib_mode_;
}
inline ::cmd::HeatCamera::SetCalibMode* Root::mutable_set_calib_mode() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::SetCalibMode* _msg = _internal_mutable_set_calib_mode();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.set_calib_mode)
  return _msg;
}

// .cmd.HeatCamera.SetDigitalZoomLevel set_digital_zoom_level = 32;
inline bool Root::has_set_digital_zoom_level() const {
  return cmd_case() == kSetDigitalZoomLevel;
}
inline bool Root::_internal_has_set_digital_zoom_level() const {
  return cmd_case() == kSetDigitalZoomLevel;
}
inline void Root::set_has_set_digital_zoom_level() {
  _impl_._oneof_case_[0] = kSetDigitalZoomLevel;
}
inline void Root::clear_set_digital_zoom_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kSetDigitalZoomLevel) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.set_digital_zoom_level_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::SetDigitalZoomLevel* Root::release_set_digital_zoom_level() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.set_digital_zoom_level)
  if (cmd_case() == kSetDigitalZoomLevel) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_digital_zoom_level_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.set_digital_zoom_level_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::SetDigitalZoomLevel& Root::_internal_set_digital_zoom_level() const {
  return cmd_case() == kSetDigitalZoomLevel ? *_impl_.cmd_.set_digital_zoom_level_ : reinterpret_cast<::cmd::HeatCamera::SetDigitalZoomLevel&>(::cmd::HeatCamera::_SetDigitalZoomLevel_default_instance_);
}
inline const ::cmd::HeatCamera::SetDigitalZoomLevel& Root::set_digital_zoom_level() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.set_digital_zoom_level)
  return _internal_set_digital_zoom_level();
}
inline ::cmd::HeatCamera::SetDigitalZoomLevel* Root::unsafe_arena_release_set_digital_zoom_level() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.set_digital_zoom_level)
  if (cmd_case() == kSetDigitalZoomLevel) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_digital_zoom_level_;
    _impl_.cmd_.set_digital_zoom_level_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_set_digital_zoom_level(::cmd::HeatCamera::SetDigitalZoomLevel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_set_digital_zoom_level();
    _impl_.cmd_.set_digital_zoom_level_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.set_digital_zoom_level)
}
inline ::cmd::HeatCamera::SetDigitalZoomLevel* Root::_internal_mutable_set_digital_zoom_level() {
  if (cmd_case() != kSetDigitalZoomLevel) {
    clear_cmd();
    set_has_set_digital_zoom_level();
    _impl_.cmd_.set_digital_zoom_level_ = CreateMaybeMessage<::cmd::HeatCamera::SetDigitalZoomLevel>(GetArena());
  }
  return _impl_.cmd_.set_digital_zoom_level_;
}
inline ::cmd::HeatCamera::SetDigitalZoomLevel* Root::mutable_set_digital_zoom_level() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::SetDigitalZoomLevel* _msg = _internal_mutable_set_digital_zoom_level();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.set_digital_zoom_level)
  return _msg;
}

// .cmd.HeatCamera.SetClaheLevel set_clahe_level = 33;
inline bool Root::has_set_clahe_level() const {
  return cmd_case() == kSetClaheLevel;
}
inline bool Root::_internal_has_set_clahe_level() const {
  return cmd_case() == kSetClaheLevel;
}
inline void Root::set_has_set_clahe_level() {
  _impl_._oneof_case_[0] = kSetClaheLevel;
}
inline void Root::clear_set_clahe_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kSetClaheLevel) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.set_clahe_level_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::SetClaheLevel* Root::release_set_clahe_level() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.set_clahe_level)
  if (cmd_case() == kSetClaheLevel) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_clahe_level_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.set_clahe_level_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::SetClaheLevel& Root::_internal_set_clahe_level() const {
  return cmd_case() == kSetClaheLevel ? *_impl_.cmd_.set_clahe_level_ : reinterpret_cast<::cmd::HeatCamera::SetClaheLevel&>(::cmd::HeatCamera::_SetClaheLevel_default_instance_);
}
inline const ::cmd::HeatCamera::SetClaheLevel& Root::set_clahe_level() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.set_clahe_level)
  return _internal_set_clahe_level();
}
inline ::cmd::HeatCamera::SetClaheLevel* Root::unsafe_arena_release_set_clahe_level() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.set_clahe_level)
  if (cmd_case() == kSetClaheLevel) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_clahe_level_;
    _impl_.cmd_.set_clahe_level_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_set_clahe_level(::cmd::HeatCamera::SetClaheLevel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_set_clahe_level();
    _impl_.cmd_.set_clahe_level_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.set_clahe_level)
}
inline ::cmd::HeatCamera::SetClaheLevel* Root::_internal_mutable_set_clahe_level() {
  if (cmd_case() != kSetClaheLevel) {
    clear_cmd();
    set_has_set_clahe_level();
    _impl_.cmd_.set_clahe_level_ = CreateMaybeMessage<::cmd::HeatCamera::SetClaheLevel>(GetArena());
  }
  return _impl_.cmd_.set_clahe_level_;
}
inline ::cmd::HeatCamera::SetClaheLevel* Root::mutable_set_clahe_level() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::SetClaheLevel* _msg = _internal_mutable_set_clahe_level();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.set_clahe_level)
  return _msg;
}

// .cmd.HeatCamera.ShiftClaheLevel shift_clahe_level = 34;
inline bool Root::has_shift_clahe_level() const {
  return cmd_case() == kShiftClaheLevel;
}
inline bool Root::_internal_has_shift_clahe_level() const {
  return cmd_case() == kShiftClaheLevel;
}
inline void Root::set_has_shift_clahe_level() {
  _impl_._oneof_case_[0] = kShiftClaheLevel;
}
inline void Root::clear_shift_clahe_level() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kShiftClaheLevel) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.shift_clahe_level_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::ShiftClaheLevel* Root::release_shift_clahe_level() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Root.shift_clahe_level)
  if (cmd_case() == kShiftClaheLevel) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.shift_clahe_level_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.shift_clahe_level_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::ShiftClaheLevel& Root::_internal_shift_clahe_level() const {
  return cmd_case() == kShiftClaheLevel ? *_impl_.cmd_.shift_clahe_level_ : reinterpret_cast<::cmd::HeatCamera::ShiftClaheLevel&>(::cmd::HeatCamera::_ShiftClaheLevel_default_instance_);
}
inline const ::cmd::HeatCamera::ShiftClaheLevel& Root::shift_clahe_level() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Root.shift_clahe_level)
  return _internal_shift_clahe_level();
}
inline ::cmd::HeatCamera::ShiftClaheLevel* Root::unsafe_arena_release_shift_clahe_level() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Root.shift_clahe_level)
  if (cmd_case() == kShiftClaheLevel) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.shift_clahe_level_;
    _impl_.cmd_.shift_clahe_level_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Root::unsafe_arena_set_allocated_shift_clahe_level(::cmd::HeatCamera::ShiftClaheLevel* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_shift_clahe_level();
    _impl_.cmd_.shift_clahe_level_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Root.shift_clahe_level)
}
inline ::cmd::HeatCamera::ShiftClaheLevel* Root::_internal_mutable_shift_clahe_level() {
  if (cmd_case() != kShiftClaheLevel) {
    clear_cmd();
    set_has_shift_clahe_level();
    _impl_.cmd_.shift_clahe_level_ = CreateMaybeMessage<::cmd::HeatCamera::ShiftClaheLevel>(GetArena());
  }
  return _impl_.cmd_.shift_clahe_level_;
}
inline ::cmd::HeatCamera::ShiftClaheLevel* Root::mutable_shift_clahe_level() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::ShiftClaheLevel* _msg = _internal_mutable_shift_clahe_level();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Root.shift_clahe_level)
  return _msg;
}

inline bool Root::has_cmd() const {
  return cmd_case() != CMD_NOT_SET;
}
inline void Root::clear_has_cmd() {
  _impl_._oneof_case_[0] = CMD_NOT_SET;
}
inline Root::CmdCase Root::cmd_case() const {
  return Root::CmdCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SetFxMode

// .ser.JonGuiDataFxModeHeat mode = 1;
inline void SetFxMode::clear_mode() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.mode_ = 0;
}
inline ::ser::JonGuiDataFxModeHeat SetFxMode::mode() const {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.SetFxMode.mode)
  return _internal_mode();
}
inline void SetFxMode::set_mode(::ser::JonGuiDataFxModeHeat value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:cmd.HeatCamera.SetFxMode.mode)
}
inline ::ser::JonGuiDataFxModeHeat SetFxMode::_internal_mode() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ser::JonGuiDataFxModeHeat>(_impl_.mode_);
}
inline void SetFxMode::_internal_set_mode(::ser::JonGuiDataFxModeHeat value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.mode_ = value;
}

// -------------------------------------------------------------------

// SetClaheLevel

// float value = 1;
inline void SetClaheLevel::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
}
inline float SetClaheLevel::value() const {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.SetClaheLevel.value)
  return _internal_value();
}
inline void SetClaheLevel::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cmd.HeatCamera.SetClaheLevel.value)
}
inline float SetClaheLevel::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void SetClaheLevel::_internal_set_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ShiftClaheLevel

// float value = 1;
inline void ShiftClaheLevel::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
}
inline float ShiftClaheLevel::value() const {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.ShiftClaheLevel.value)
  return _internal_value();
}
inline void ShiftClaheLevel::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cmd.HeatCamera.ShiftClaheLevel.value)
}
inline float ShiftClaheLevel::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void ShiftClaheLevel::_internal_set_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// NextFxMode

// -------------------------------------------------------------------

// PrevFxMode

// -------------------------------------------------------------------

// RefreshFxMode

// -------------------------------------------------------------------

// EnableDDE

// -------------------------------------------------------------------

// DisableDDE

// -------------------------------------------------------------------

// SetValue

// float value = 1;
inline void SetValue::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
}
inline float SetValue::value() const {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.SetValue.value)
  return _internal_value();
}
inline void SetValue::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cmd.HeatCamera.SetValue.value)
}
inline float SetValue::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void SetValue::_internal_set_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// SetDDELevel

// int32 value = 1;
inline void SetDDELevel::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
}
inline ::int32_t SetDDELevel::value() const {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.SetDDELevel.value)
  return _internal_value();
}
inline void SetDDELevel::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cmd.HeatCamera.SetDDELevel.value)
}
inline ::int32_t SetDDELevel::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void SetDDELevel::_internal_set_value(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// SetDigitalZoomLevel

// float value = 1;
inline void SetDigitalZoomLevel::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
}
inline float SetDigitalZoomLevel::value() const {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.SetDigitalZoomLevel.value)
  return _internal_value();
}
inline void SetDigitalZoomLevel::set_value(float value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cmd.HeatCamera.SetDigitalZoomLevel.value)
}
inline float SetDigitalZoomLevel::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void SetDigitalZoomLevel::_internal_set_value(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ShiftDDE

// int32 value = 1;
inline void ShiftDDE::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
}
inline ::int32_t ShiftDDE::value() const {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.ShiftDDE.value)
  return _internal_value();
}
inline void ShiftDDE::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cmd.HeatCamera.ShiftDDE.value)
}
inline ::int32_t ShiftDDE::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void ShiftDDE::_internal_set_value(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ZoomIn

// -------------------------------------------------------------------

// ZoomOut

// -------------------------------------------------------------------

// ZoomStop

// -------------------------------------------------------------------

// FocusIn

// -------------------------------------------------------------------

// FocusOut

// -------------------------------------------------------------------

// FocusStop

// -------------------------------------------------------------------

// FocusStepPlus

// -------------------------------------------------------------------

// FocusStepMinus

// -------------------------------------------------------------------

// Calibrate

// -------------------------------------------------------------------

// Zoom

// .cmd.HeatCamera.SetZoomTableValue set_zoom_table_value = 1;
inline bool Zoom::has_set_zoom_table_value() const {
  return cmd_case() == kSetZoomTableValue;
}
inline bool Zoom::_internal_has_set_zoom_table_value() const {
  return cmd_case() == kSetZoomTableValue;
}
inline void Zoom::set_has_set_zoom_table_value() {
  _impl_._oneof_case_[0] = kSetZoomTableValue;
}
inline void Zoom::clear_set_zoom_table_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kSetZoomTableValue) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.set_zoom_table_value_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::SetZoomTableValue* Zoom::release_set_zoom_table_value() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Zoom.set_zoom_table_value)
  if (cmd_case() == kSetZoomTableValue) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_zoom_table_value_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.set_zoom_table_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::SetZoomTableValue& Zoom::_internal_set_zoom_table_value() const {
  return cmd_case() == kSetZoomTableValue ? *_impl_.cmd_.set_zoom_table_value_ : reinterpret_cast<::cmd::HeatCamera::SetZoomTableValue&>(::cmd::HeatCamera::_SetZoomTableValue_default_instance_);
}
inline const ::cmd::HeatCamera::SetZoomTableValue& Zoom::set_zoom_table_value() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Zoom.set_zoom_table_value)
  return _internal_set_zoom_table_value();
}
inline ::cmd::HeatCamera::SetZoomTableValue* Zoom::unsafe_arena_release_set_zoom_table_value() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Zoom.set_zoom_table_value)
  if (cmd_case() == kSetZoomTableValue) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.set_zoom_table_value_;
    _impl_.cmd_.set_zoom_table_value_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Zoom::unsafe_arena_set_allocated_set_zoom_table_value(::cmd::HeatCamera::SetZoomTableValue* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_set_zoom_table_value();
    _impl_.cmd_.set_zoom_table_value_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Zoom.set_zoom_table_value)
}
inline ::cmd::HeatCamera::SetZoomTableValue* Zoom::_internal_mutable_set_zoom_table_value() {
  if (cmd_case() != kSetZoomTableValue) {
    clear_cmd();
    set_has_set_zoom_table_value();
    _impl_.cmd_.set_zoom_table_value_ = CreateMaybeMessage<::cmd::HeatCamera::SetZoomTableValue>(GetArena());
  }
  return _impl_.cmd_.set_zoom_table_value_;
}
inline ::cmd::HeatCamera::SetZoomTableValue* Zoom::mutable_set_zoom_table_value() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::SetZoomTableValue* _msg = _internal_mutable_set_zoom_table_value();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Zoom.set_zoom_table_value)
  return _msg;
}

// .cmd.HeatCamera.NextZoomTablePos next_zoom_table_pos = 2;
inline bool Zoom::has_next_zoom_table_pos() const {
  return cmd_case() == kNextZoomTablePos;
}
inline bool Zoom::_internal_has_next_zoom_table_pos() const {
  return cmd_case() == kNextZoomTablePos;
}
inline void Zoom::set_has_next_zoom_table_pos() {
  _impl_._oneof_case_[0] = kNextZoomTablePos;
}
inline void Zoom::clear_next_zoom_table_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kNextZoomTablePos) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.next_zoom_table_pos_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::NextZoomTablePos* Zoom::release_next_zoom_table_pos() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Zoom.next_zoom_table_pos)
  if (cmd_case() == kNextZoomTablePos) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.next_zoom_table_pos_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.next_zoom_table_pos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::NextZoomTablePos& Zoom::_internal_next_zoom_table_pos() const {
  return cmd_case() == kNextZoomTablePos ? *_impl_.cmd_.next_zoom_table_pos_ : reinterpret_cast<::cmd::HeatCamera::NextZoomTablePos&>(::cmd::HeatCamera::_NextZoomTablePos_default_instance_);
}
inline const ::cmd::HeatCamera::NextZoomTablePos& Zoom::next_zoom_table_pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Zoom.next_zoom_table_pos)
  return _internal_next_zoom_table_pos();
}
inline ::cmd::HeatCamera::NextZoomTablePos* Zoom::unsafe_arena_release_next_zoom_table_pos() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Zoom.next_zoom_table_pos)
  if (cmd_case() == kNextZoomTablePos) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.next_zoom_table_pos_;
    _impl_.cmd_.next_zoom_table_pos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Zoom::unsafe_arena_set_allocated_next_zoom_table_pos(::cmd::HeatCamera::NextZoomTablePos* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_next_zoom_table_pos();
    _impl_.cmd_.next_zoom_table_pos_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Zoom.next_zoom_table_pos)
}
inline ::cmd::HeatCamera::NextZoomTablePos* Zoom::_internal_mutable_next_zoom_table_pos() {
  if (cmd_case() != kNextZoomTablePos) {
    clear_cmd();
    set_has_next_zoom_table_pos();
    _impl_.cmd_.next_zoom_table_pos_ = CreateMaybeMessage<::cmd::HeatCamera::NextZoomTablePos>(GetArena());
  }
  return _impl_.cmd_.next_zoom_table_pos_;
}
inline ::cmd::HeatCamera::NextZoomTablePos* Zoom::mutable_next_zoom_table_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::NextZoomTablePos* _msg = _internal_mutable_next_zoom_table_pos();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Zoom.next_zoom_table_pos)
  return _msg;
}

// .cmd.HeatCamera.PrevZoomTablePos prev_zoom_table_pos = 3;
inline bool Zoom::has_prev_zoom_table_pos() const {
  return cmd_case() == kPrevZoomTablePos;
}
inline bool Zoom::_internal_has_prev_zoom_table_pos() const {
  return cmd_case() == kPrevZoomTablePos;
}
inline void Zoom::set_has_prev_zoom_table_pos() {
  _impl_._oneof_case_[0] = kPrevZoomTablePos;
}
inline void Zoom::clear_prev_zoom_table_pos() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (cmd_case() == kPrevZoomTablePos) {
    if (GetArena() == nullptr) {
      delete _impl_.cmd_.prev_zoom_table_pos_;
    }
    clear_has_cmd();
  }
}
inline ::cmd::HeatCamera::PrevZoomTablePos* Zoom::release_prev_zoom_table_pos() {
  // @@protoc_insertion_point(field_release:cmd.HeatCamera.Zoom.prev_zoom_table_pos)
  if (cmd_case() == kPrevZoomTablePos) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.prev_zoom_table_pos_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.cmd_.prev_zoom_table_pos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::cmd::HeatCamera::PrevZoomTablePos& Zoom::_internal_prev_zoom_table_pos() const {
  return cmd_case() == kPrevZoomTablePos ? *_impl_.cmd_.prev_zoom_table_pos_ : reinterpret_cast<::cmd::HeatCamera::PrevZoomTablePos&>(::cmd::HeatCamera::_PrevZoomTablePos_default_instance_);
}
inline const ::cmd::HeatCamera::PrevZoomTablePos& Zoom::prev_zoom_table_pos() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.Zoom.prev_zoom_table_pos)
  return _internal_prev_zoom_table_pos();
}
inline ::cmd::HeatCamera::PrevZoomTablePos* Zoom::unsafe_arena_release_prev_zoom_table_pos() {
  // @@protoc_insertion_point(field_unsafe_arena_release:cmd.HeatCamera.Zoom.prev_zoom_table_pos)
  if (cmd_case() == kPrevZoomTablePos) {
    clear_has_cmd();
    auto* temp = _impl_.cmd_.prev_zoom_table_pos_;
    _impl_.cmd_.prev_zoom_table_pos_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Zoom::unsafe_arena_set_allocated_prev_zoom_table_pos(::cmd::HeatCamera::PrevZoomTablePos* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_cmd();
  if (value) {
    set_has_prev_zoom_table_pos();
    _impl_.cmd_.prev_zoom_table_pos_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:cmd.HeatCamera.Zoom.prev_zoom_table_pos)
}
inline ::cmd::HeatCamera::PrevZoomTablePos* Zoom::_internal_mutable_prev_zoom_table_pos() {
  if (cmd_case() != kPrevZoomTablePos) {
    clear_cmd();
    set_has_prev_zoom_table_pos();
    _impl_.cmd_.prev_zoom_table_pos_ = CreateMaybeMessage<::cmd::HeatCamera::PrevZoomTablePos>(GetArena());
  }
  return _impl_.cmd_.prev_zoom_table_pos_;
}
inline ::cmd::HeatCamera::PrevZoomTablePos* Zoom::mutable_prev_zoom_table_pos() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::cmd::HeatCamera::PrevZoomTablePos* _msg = _internal_mutable_prev_zoom_table_pos();
  // @@protoc_insertion_point(field_mutable:cmd.HeatCamera.Zoom.prev_zoom_table_pos)
  return _msg;
}

inline bool Zoom::has_cmd() const {
  return cmd_case() != CMD_NOT_SET;
}
inline void Zoom::clear_has_cmd() {
  _impl_._oneof_case_[0] = CMD_NOT_SET;
}
inline Zoom::CmdCase Zoom::cmd_case() const {
  return Zoom::CmdCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NextZoomTablePos

// -------------------------------------------------------------------

// PrevZoomTablePos

// -------------------------------------------------------------------

// SetCalibMode

// -------------------------------------------------------------------

// SetZoomTableValue

// int32 value = 1;
inline void SetZoomTableValue::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
}
inline ::int32_t SetZoomTableValue::value() const {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.SetZoomTableValue.value)
  return _internal_value();
}
inline void SetZoomTableValue::set_value(::int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cmd.HeatCamera.SetZoomTableValue.value)
}
inline ::int32_t SetZoomTableValue::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void SetZoomTableValue::_internal_set_value(::int32_t value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// SetAGC

// .ser.JonGuiDataVideoChannelHeatAGCModes value = 1;
inline void SetAGC::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
}
inline ::ser::JonGuiDataVideoChannelHeatAGCModes SetAGC::value() const {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.SetAGC.value)
  return _internal_value();
}
inline void SetAGC::set_value(::ser::JonGuiDataVideoChannelHeatAGCModes value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cmd.HeatCamera.SetAGC.value)
}
inline ::ser::JonGuiDataVideoChannelHeatAGCModes SetAGC::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ser::JonGuiDataVideoChannelHeatAGCModes>(_impl_.value_);
}
inline void SetAGC::_internal_set_value(::ser::JonGuiDataVideoChannelHeatAGCModes value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// SetFilters

// .ser.JonGuiDataVideoChannelHeatFilters value = 1;
inline void SetFilters::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = 0;
}
inline ::ser::JonGuiDataVideoChannelHeatFilters SetFilters::value() const {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.SetFilters.value)
  return _internal_value();
}
inline void SetFilters::set_value(::ser::JonGuiDataVideoChannelHeatFilters value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cmd.HeatCamera.SetFilters.value)
}
inline ::ser::JonGuiDataVideoChannelHeatFilters SetFilters::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::ser::JonGuiDataVideoChannelHeatFilters>(_impl_.value_);
}
inline void SetFilters::_internal_set_value(::ser::JonGuiDataVideoChannelHeatFilters value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// Start

// -------------------------------------------------------------------

// Stop

// -------------------------------------------------------------------

// Halt

// -------------------------------------------------------------------

// Photo

// -------------------------------------------------------------------

// GetMeteo

// -------------------------------------------------------------------

// SetAutoFocus

// bool value = 1;
inline void SetAutoFocus::clear_value() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.value_ = false;
}
inline bool SetAutoFocus::value() const {
  // @@protoc_insertion_point(field_get:cmd.HeatCamera.SetAutoFocus.value)
  return _internal_value();
}
inline void SetAutoFocus::set_value(bool value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:cmd.HeatCamera.SetAutoFocus.value)
}
inline bool SetAutoFocus::_internal_value() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.value_;
}
inline void SetAutoFocus::_internal_set_value(bool value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.value_ = value;
}

// -------------------------------------------------------------------

// ResetZoom

// -------------------------------------------------------------------

// SaveToTable

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace HeatCamera
}  // namespace cmd


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_jon_5fshared_5fcmd_5fheat_5fcamera_2eproto_2epb_2eh
