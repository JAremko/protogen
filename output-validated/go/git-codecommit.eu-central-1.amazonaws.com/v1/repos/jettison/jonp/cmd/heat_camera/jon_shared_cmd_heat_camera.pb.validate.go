// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: jon_shared_cmd_heat_camera.proto

package heat_camera

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	types "git-codecommit.eu-central-1.amazonaws.com/v1/repos/jettison/jonp/types"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = types.JonGuiDataFxModeHeat(0)
)

// Validate checks the field values on Root with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Root) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Root with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RootMultiError, or nil if none found.
func (m *Root) ValidateAll() error {
	return m.validate(true)
}

func (m *Root) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Cmd.(type) {
	case *Root_Zoom:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetZoom()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Zoom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Zoom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetZoom()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "Zoom",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_SetAgc:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetAgc()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetAgc",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetAgc",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetAgc()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "SetAgc",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_SetFilter:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetFilter()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetFilter",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetFilter",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetFilter()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "SetFilter",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_Start:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStart()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Start",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Start",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_Stop:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStop()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Stop",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Stop",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStop()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "Stop",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_Photo:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPhoto()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Photo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Photo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPhoto()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "Photo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_ZoomIn:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetZoomIn()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ZoomIn",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ZoomIn",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetZoomIn()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "ZoomIn",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_ZoomOut:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetZoomOut()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ZoomOut",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ZoomOut",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetZoomOut()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "ZoomOut",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_ZoomStop:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetZoomStop()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ZoomStop",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ZoomStop",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetZoomStop()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "ZoomStop",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_FocusIn:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFocusIn()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "FocusIn",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "FocusIn",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFocusIn()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "FocusIn",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_FocusOut:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFocusOut()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "FocusOut",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "FocusOut",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFocusOut()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "FocusOut",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_FocusStop:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFocusStop()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "FocusStop",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "FocusStop",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFocusStop()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "FocusStop",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_Calibrate:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetCalibrate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Calibrate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Calibrate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetCalibrate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "Calibrate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_SetDdeLevel:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetDdeLevel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetDdeLevel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetDdeLevel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetDdeLevel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "SetDdeLevel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_EnableDde:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetEnableDde()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "EnableDde",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "EnableDde",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEnableDde()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "EnableDde",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_DisableDde:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDisableDde()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "DisableDde",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "DisableDde",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDisableDde()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "DisableDde",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_SetAutoFocus:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetAutoFocus()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetAutoFocus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetAutoFocus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetAutoFocus()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "SetAutoFocus",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_FocusStepPlus:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFocusStepPlus()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "FocusStepPlus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "FocusStepPlus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFocusStepPlus()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "FocusStepPlus",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_FocusStepMinus:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetFocusStepMinus()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "FocusStepMinus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "FocusStepMinus",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFocusStepMinus()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "FocusStepMinus",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_SetFxMode:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetFxMode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetFxMode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetFxMode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetFxMode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "SetFxMode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_NextFxMode:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNextFxMode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "NextFxMode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "NextFxMode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNextFxMode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "NextFxMode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_PrevFxMode:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPrevFxMode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "PrevFxMode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "PrevFxMode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPrevFxMode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "PrevFxMode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_GetMeteo:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGetMeteo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "GetMeteo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "GetMeteo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGetMeteo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "GetMeteo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_ShiftDde:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetShiftDde()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ShiftDde",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ShiftDde",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetShiftDde()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "ShiftDde",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_RefreshFxMode:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRefreshFxMode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "RefreshFxMode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "RefreshFxMode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRefreshFxMode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "RefreshFxMode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_ResetZoom:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetResetZoom()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ResetZoom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ResetZoom",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetResetZoom()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "ResetZoom",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_SaveToTable:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSaveToTable()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SaveToTable",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SaveToTable",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSaveToTable()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "SaveToTable",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_SetCalibMode:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetCalibMode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetCalibMode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetCalibMode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetCalibMode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "SetCalibMode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_SetDigitalZoomLevel:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetDigitalZoomLevel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetDigitalZoomLevel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetDigitalZoomLevel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetDigitalZoomLevel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "SetDigitalZoomLevel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_SetClaheLevel:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetClaheLevel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetClaheLevel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetClaheLevel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetClaheLevel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "SetClaheLevel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_ShiftClaheLevel:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetShiftClaheLevel()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ShiftClaheLevel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ShiftClaheLevel",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetShiftClaheLevel()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "ShiftClaheLevel",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return RootMultiError(errors)
	}

	return nil
}

// RootMultiError is an error wrapping multiple validation errors returned by
// Root.ValidateAll() if the designated constraints aren't met.
type RootMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RootMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RootMultiError) AllErrors() []error { return m }

// RootValidationError is the validation error returned by Root.Validate if the
// designated constraints aren't met.
type RootValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RootValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RootValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RootValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RootValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RootValidationError) ErrorName() string { return "RootValidationError" }

// Error satisfies the builtin error interface
func (e RootValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RootValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RootValidationError{}

// Validate checks the field values on SetFxMode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetFxMode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetFxMode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SetFxModeMultiError, or nil
// if none found.
func (m *SetFxMode) ValidateAll() error {
	return m.validate(true)
}

func (m *SetFxMode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mode

	if len(errors) > 0 {
		return SetFxModeMultiError(errors)
	}

	return nil
}

// SetFxModeMultiError is an error wrapping multiple validation errors returned
// by SetFxMode.ValidateAll() if the designated constraints aren't met.
type SetFxModeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetFxModeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetFxModeMultiError) AllErrors() []error { return m }

// SetFxModeValidationError is the validation error returned by
// SetFxMode.Validate if the designated constraints aren't met.
type SetFxModeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetFxModeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetFxModeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetFxModeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetFxModeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetFxModeValidationError) ErrorName() string { return "SetFxModeValidationError" }

// Error satisfies the builtin error interface
func (e SetFxModeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetFxMode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetFxModeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetFxModeValidationError{}

// Validate checks the field values on SetClaheLevel with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetClaheLevel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetClaheLevel with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SetClaheLevelMultiError, or
// nil if none found.
func (m *SetClaheLevel) ValidateAll() error {
	return m.validate(true)
}

func (m *SetClaheLevel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SetClaheLevelMultiError(errors)
	}

	return nil
}

// SetClaheLevelMultiError is an error wrapping multiple validation errors
// returned by SetClaheLevel.ValidateAll() if the designated constraints
// aren't met.
type SetClaheLevelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetClaheLevelMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetClaheLevelMultiError) AllErrors() []error { return m }

// SetClaheLevelValidationError is the validation error returned by
// SetClaheLevel.Validate if the designated constraints aren't met.
type SetClaheLevelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetClaheLevelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetClaheLevelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetClaheLevelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetClaheLevelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetClaheLevelValidationError) ErrorName() string { return "SetClaheLevelValidationError" }

// Error satisfies the builtin error interface
func (e SetClaheLevelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetClaheLevel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetClaheLevelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetClaheLevelValidationError{}

// Validate checks the field values on ShiftClaheLevel with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ShiftClaheLevel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ShiftClaheLevel with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ShiftClaheLevelMultiError, or nil if none found.
func (m *ShiftClaheLevel) ValidateAll() error {
	return m.validate(true)
}

func (m *ShiftClaheLevel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return ShiftClaheLevelMultiError(errors)
	}

	return nil
}

// ShiftClaheLevelMultiError is an error wrapping multiple validation errors
// returned by ShiftClaheLevel.ValidateAll() if the designated constraints
// aren't met.
type ShiftClaheLevelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ShiftClaheLevelMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ShiftClaheLevelMultiError) AllErrors() []error { return m }

// ShiftClaheLevelValidationError is the validation error returned by
// ShiftClaheLevel.Validate if the designated constraints aren't met.
type ShiftClaheLevelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ShiftClaheLevelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ShiftClaheLevelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ShiftClaheLevelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ShiftClaheLevelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ShiftClaheLevelValidationError) ErrorName() string { return "ShiftClaheLevelValidationError" }

// Error satisfies the builtin error interface
func (e ShiftClaheLevelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sShiftClaheLevel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ShiftClaheLevelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ShiftClaheLevelValidationError{}

// Validate checks the field values on NextFxMode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NextFxMode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NextFxMode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NextFxModeMultiError, or
// nil if none found.
func (m *NextFxMode) ValidateAll() error {
	return m.validate(true)
}

func (m *NextFxMode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return NextFxModeMultiError(errors)
	}

	return nil
}

// NextFxModeMultiError is an error wrapping multiple validation errors
// returned by NextFxMode.ValidateAll() if the designated constraints aren't met.
type NextFxModeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NextFxModeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NextFxModeMultiError) AllErrors() []error { return m }

// NextFxModeValidationError is the validation error returned by
// NextFxMode.Validate if the designated constraints aren't met.
type NextFxModeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NextFxModeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NextFxModeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NextFxModeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NextFxModeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NextFxModeValidationError) ErrorName() string { return "NextFxModeValidationError" }

// Error satisfies the builtin error interface
func (e NextFxModeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNextFxMode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NextFxModeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NextFxModeValidationError{}

// Validate checks the field values on PrevFxMode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PrevFxMode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrevFxMode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PrevFxModeMultiError, or
// nil if none found.
func (m *PrevFxMode) ValidateAll() error {
	return m.validate(true)
}

func (m *PrevFxMode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PrevFxModeMultiError(errors)
	}

	return nil
}

// PrevFxModeMultiError is an error wrapping multiple validation errors
// returned by PrevFxMode.ValidateAll() if the designated constraints aren't met.
type PrevFxModeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrevFxModeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrevFxModeMultiError) AllErrors() []error { return m }

// PrevFxModeValidationError is the validation error returned by
// PrevFxMode.Validate if the designated constraints aren't met.
type PrevFxModeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrevFxModeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrevFxModeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrevFxModeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrevFxModeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrevFxModeValidationError) ErrorName() string { return "PrevFxModeValidationError" }

// Error satisfies the builtin error interface
func (e PrevFxModeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrevFxMode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrevFxModeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrevFxModeValidationError{}

// Validate checks the field values on RefreshFxMode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RefreshFxMode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RefreshFxMode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RefreshFxModeMultiError, or
// nil if none found.
func (m *RefreshFxMode) ValidateAll() error {
	return m.validate(true)
}

func (m *RefreshFxMode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return RefreshFxModeMultiError(errors)
	}

	return nil
}

// RefreshFxModeMultiError is an error wrapping multiple validation errors
// returned by RefreshFxMode.ValidateAll() if the designated constraints
// aren't met.
type RefreshFxModeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RefreshFxModeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RefreshFxModeMultiError) AllErrors() []error { return m }

// RefreshFxModeValidationError is the validation error returned by
// RefreshFxMode.Validate if the designated constraints aren't met.
type RefreshFxModeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RefreshFxModeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RefreshFxModeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RefreshFxModeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RefreshFxModeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RefreshFxModeValidationError) ErrorName() string { return "RefreshFxModeValidationError" }

// Error satisfies the builtin error interface
func (e RefreshFxModeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRefreshFxMode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RefreshFxModeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RefreshFxModeValidationError{}

// Validate checks the field values on EnableDDE with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EnableDDE) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnableDDE with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnableDDEMultiError, or nil
// if none found.
func (m *EnableDDE) ValidateAll() error {
	return m.validate(true)
}

func (m *EnableDDE) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return EnableDDEMultiError(errors)
	}

	return nil
}

// EnableDDEMultiError is an error wrapping multiple validation errors returned
// by EnableDDE.ValidateAll() if the designated constraints aren't met.
type EnableDDEMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnableDDEMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnableDDEMultiError) AllErrors() []error { return m }

// EnableDDEValidationError is the validation error returned by
// EnableDDE.Validate if the designated constraints aren't met.
type EnableDDEValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnableDDEValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnableDDEValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnableDDEValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnableDDEValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnableDDEValidationError) ErrorName() string { return "EnableDDEValidationError" }

// Error satisfies the builtin error interface
func (e EnableDDEValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnableDDE.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnableDDEValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnableDDEValidationError{}

// Validate checks the field values on DisableDDE with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *DisableDDE) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisableDDE with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in DisableDDEMultiError, or
// nil if none found.
func (m *DisableDDE) ValidateAll() error {
	return m.validate(true)
}

func (m *DisableDDE) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DisableDDEMultiError(errors)
	}

	return nil
}

// DisableDDEMultiError is an error wrapping multiple validation errors
// returned by DisableDDE.ValidateAll() if the designated constraints aren't met.
type DisableDDEMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisableDDEMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisableDDEMultiError) AllErrors() []error { return m }

// DisableDDEValidationError is the validation error returned by
// DisableDDE.Validate if the designated constraints aren't met.
type DisableDDEValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisableDDEValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisableDDEValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisableDDEValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisableDDEValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisableDDEValidationError) ErrorName() string { return "DisableDDEValidationError" }

// Error satisfies the builtin error interface
func (e DisableDDEValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisableDDE.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisableDDEValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisableDDEValidationError{}

// Validate checks the field values on SetValue with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetValue with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SetValueMultiError, or nil
// if none found.
func (m *SetValue) ValidateAll() error {
	return m.validate(true)
}

func (m *SetValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SetValueMultiError(errors)
	}

	return nil
}

// SetValueMultiError is an error wrapping multiple validation errors returned
// by SetValue.ValidateAll() if the designated constraints aren't met.
type SetValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetValueMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetValueMultiError) AllErrors() []error { return m }

// SetValueValidationError is the validation error returned by
// SetValue.Validate if the designated constraints aren't met.
type SetValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetValueValidationError) ErrorName() string { return "SetValueValidationError" }

// Error satisfies the builtin error interface
func (e SetValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetValueValidationError{}

// Validate checks the field values on SetDDELevel with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetDDELevel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetDDELevel with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SetDDELevelMultiError, or
// nil if none found.
func (m *SetDDELevel) ValidateAll() error {
	return m.validate(true)
}

func (m *SetDDELevel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SetDDELevelMultiError(errors)
	}

	return nil
}

// SetDDELevelMultiError is an error wrapping multiple validation errors
// returned by SetDDELevel.ValidateAll() if the designated constraints aren't met.
type SetDDELevelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetDDELevelMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetDDELevelMultiError) AllErrors() []error { return m }

// SetDDELevelValidationError is the validation error returned by
// SetDDELevel.Validate if the designated constraints aren't met.
type SetDDELevelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetDDELevelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetDDELevelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetDDELevelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetDDELevelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetDDELevelValidationError) ErrorName() string { return "SetDDELevelValidationError" }

// Error satisfies the builtin error interface
func (e SetDDELevelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetDDELevel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetDDELevelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetDDELevelValidationError{}

// Validate checks the field values on SetDigitalZoomLevel with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetDigitalZoomLevel) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetDigitalZoomLevel with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetDigitalZoomLevelMultiError, or nil if none found.
func (m *SetDigitalZoomLevel) ValidateAll() error {
	return m.validate(true)
}

func (m *SetDigitalZoomLevel) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SetDigitalZoomLevelMultiError(errors)
	}

	return nil
}

// SetDigitalZoomLevelMultiError is an error wrapping multiple validation
// errors returned by SetDigitalZoomLevel.ValidateAll() if the designated
// constraints aren't met.
type SetDigitalZoomLevelMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetDigitalZoomLevelMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetDigitalZoomLevelMultiError) AllErrors() []error { return m }

// SetDigitalZoomLevelValidationError is the validation error returned by
// SetDigitalZoomLevel.Validate if the designated constraints aren't met.
type SetDigitalZoomLevelValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetDigitalZoomLevelValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetDigitalZoomLevelValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetDigitalZoomLevelValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetDigitalZoomLevelValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetDigitalZoomLevelValidationError) ErrorName() string {
	return "SetDigitalZoomLevelValidationError"
}

// Error satisfies the builtin error interface
func (e SetDigitalZoomLevelValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetDigitalZoomLevel.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetDigitalZoomLevelValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetDigitalZoomLevelValidationError{}

// Validate checks the field values on ShiftDDE with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ShiftDDE) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ShiftDDE with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ShiftDDEMultiError, or nil
// if none found.
func (m *ShiftDDE) ValidateAll() error {
	return m.validate(true)
}

func (m *ShiftDDE) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return ShiftDDEMultiError(errors)
	}

	return nil
}

// ShiftDDEMultiError is an error wrapping multiple validation errors returned
// by ShiftDDE.ValidateAll() if the designated constraints aren't met.
type ShiftDDEMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ShiftDDEMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ShiftDDEMultiError) AllErrors() []error { return m }

// ShiftDDEValidationError is the validation error returned by
// ShiftDDE.Validate if the designated constraints aren't met.
type ShiftDDEValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ShiftDDEValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ShiftDDEValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ShiftDDEValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ShiftDDEValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ShiftDDEValidationError) ErrorName() string { return "ShiftDDEValidationError" }

// Error satisfies the builtin error interface
func (e ShiftDDEValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sShiftDDE.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ShiftDDEValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ShiftDDEValidationError{}

// Validate checks the field values on ZoomIn with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ZoomIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ZoomIn with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ZoomInMultiError, or nil if none found.
func (m *ZoomIn) ValidateAll() error {
	return m.validate(true)
}

func (m *ZoomIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ZoomInMultiError(errors)
	}

	return nil
}

// ZoomInMultiError is an error wrapping multiple validation errors returned by
// ZoomIn.ValidateAll() if the designated constraints aren't met.
type ZoomInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ZoomInMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ZoomInMultiError) AllErrors() []error { return m }

// ZoomInValidationError is the validation error returned by ZoomIn.Validate if
// the designated constraints aren't met.
type ZoomInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ZoomInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ZoomInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ZoomInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ZoomInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ZoomInValidationError) ErrorName() string { return "ZoomInValidationError" }

// Error satisfies the builtin error interface
func (e ZoomInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sZoomIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ZoomInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ZoomInValidationError{}

// Validate checks the field values on ZoomOut with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ZoomOut) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ZoomOut with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ZoomOutMultiError, or nil if none found.
func (m *ZoomOut) ValidateAll() error {
	return m.validate(true)
}

func (m *ZoomOut) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ZoomOutMultiError(errors)
	}

	return nil
}

// ZoomOutMultiError is an error wrapping multiple validation errors returned
// by ZoomOut.ValidateAll() if the designated constraints aren't met.
type ZoomOutMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ZoomOutMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ZoomOutMultiError) AllErrors() []error { return m }

// ZoomOutValidationError is the validation error returned by ZoomOut.Validate
// if the designated constraints aren't met.
type ZoomOutValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ZoomOutValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ZoomOutValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ZoomOutValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ZoomOutValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ZoomOutValidationError) ErrorName() string { return "ZoomOutValidationError" }

// Error satisfies the builtin error interface
func (e ZoomOutValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sZoomOut.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ZoomOutValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ZoomOutValidationError{}

// Validate checks the field values on ZoomStop with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ZoomStop) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ZoomStop with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ZoomStopMultiError, or nil
// if none found.
func (m *ZoomStop) ValidateAll() error {
	return m.validate(true)
}

func (m *ZoomStop) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ZoomStopMultiError(errors)
	}

	return nil
}

// ZoomStopMultiError is an error wrapping multiple validation errors returned
// by ZoomStop.ValidateAll() if the designated constraints aren't met.
type ZoomStopMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ZoomStopMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ZoomStopMultiError) AllErrors() []error { return m }

// ZoomStopValidationError is the validation error returned by
// ZoomStop.Validate if the designated constraints aren't met.
type ZoomStopValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ZoomStopValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ZoomStopValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ZoomStopValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ZoomStopValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ZoomStopValidationError) ErrorName() string { return "ZoomStopValidationError" }

// Error satisfies the builtin error interface
func (e ZoomStopValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sZoomStop.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ZoomStopValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ZoomStopValidationError{}

// Validate checks the field values on FocusIn with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FocusIn) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FocusIn with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in FocusInMultiError, or nil if none found.
func (m *FocusIn) ValidateAll() error {
	return m.validate(true)
}

func (m *FocusIn) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return FocusInMultiError(errors)
	}

	return nil
}

// FocusInMultiError is an error wrapping multiple validation errors returned
// by FocusIn.ValidateAll() if the designated constraints aren't met.
type FocusInMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FocusInMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FocusInMultiError) AllErrors() []error { return m }

// FocusInValidationError is the validation error returned by FocusIn.Validate
// if the designated constraints aren't met.
type FocusInValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FocusInValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FocusInValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FocusInValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FocusInValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FocusInValidationError) ErrorName() string { return "FocusInValidationError" }

// Error satisfies the builtin error interface
func (e FocusInValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFocusIn.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FocusInValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FocusInValidationError{}

// Validate checks the field values on FocusOut with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FocusOut) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FocusOut with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FocusOutMultiError, or nil
// if none found.
func (m *FocusOut) ValidateAll() error {
	return m.validate(true)
}

func (m *FocusOut) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return FocusOutMultiError(errors)
	}

	return nil
}

// FocusOutMultiError is an error wrapping multiple validation errors returned
// by FocusOut.ValidateAll() if the designated constraints aren't met.
type FocusOutMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FocusOutMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FocusOutMultiError) AllErrors() []error { return m }

// FocusOutValidationError is the validation error returned by
// FocusOut.Validate if the designated constraints aren't met.
type FocusOutValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FocusOutValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FocusOutValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FocusOutValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FocusOutValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FocusOutValidationError) ErrorName() string { return "FocusOutValidationError" }

// Error satisfies the builtin error interface
func (e FocusOutValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFocusOut.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FocusOutValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FocusOutValidationError{}

// Validate checks the field values on FocusStop with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FocusStop) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FocusStop with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FocusStopMultiError, or nil
// if none found.
func (m *FocusStop) ValidateAll() error {
	return m.validate(true)
}

func (m *FocusStop) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return FocusStopMultiError(errors)
	}

	return nil
}

// FocusStopMultiError is an error wrapping multiple validation errors returned
// by FocusStop.ValidateAll() if the designated constraints aren't met.
type FocusStopMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FocusStopMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FocusStopMultiError) AllErrors() []error { return m }

// FocusStopValidationError is the validation error returned by
// FocusStop.Validate if the designated constraints aren't met.
type FocusStopValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FocusStopValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FocusStopValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FocusStopValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FocusStopValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FocusStopValidationError) ErrorName() string { return "FocusStopValidationError" }

// Error satisfies the builtin error interface
func (e FocusStopValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFocusStop.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FocusStopValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FocusStopValidationError{}

// Validate checks the field values on FocusStepPlus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FocusStepPlus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FocusStepPlus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FocusStepPlusMultiError, or
// nil if none found.
func (m *FocusStepPlus) ValidateAll() error {
	return m.validate(true)
}

func (m *FocusStepPlus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return FocusStepPlusMultiError(errors)
	}

	return nil
}

// FocusStepPlusMultiError is an error wrapping multiple validation errors
// returned by FocusStepPlus.ValidateAll() if the designated constraints
// aren't met.
type FocusStepPlusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FocusStepPlusMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FocusStepPlusMultiError) AllErrors() []error { return m }

// FocusStepPlusValidationError is the validation error returned by
// FocusStepPlus.Validate if the designated constraints aren't met.
type FocusStepPlusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FocusStepPlusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FocusStepPlusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FocusStepPlusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FocusStepPlusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FocusStepPlusValidationError) ErrorName() string { return "FocusStepPlusValidationError" }

// Error satisfies the builtin error interface
func (e FocusStepPlusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFocusStepPlus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FocusStepPlusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FocusStepPlusValidationError{}

// Validate checks the field values on FocusStepMinus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FocusStepMinus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FocusStepMinus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FocusStepMinusMultiError,
// or nil if none found.
func (m *FocusStepMinus) ValidateAll() error {
	return m.validate(true)
}

func (m *FocusStepMinus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return FocusStepMinusMultiError(errors)
	}

	return nil
}

// FocusStepMinusMultiError is an error wrapping multiple validation errors
// returned by FocusStepMinus.ValidateAll() if the designated constraints
// aren't met.
type FocusStepMinusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FocusStepMinusMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FocusStepMinusMultiError) AllErrors() []error { return m }

// FocusStepMinusValidationError is the validation error returned by
// FocusStepMinus.Validate if the designated constraints aren't met.
type FocusStepMinusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FocusStepMinusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FocusStepMinusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FocusStepMinusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FocusStepMinusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FocusStepMinusValidationError) ErrorName() string { return "FocusStepMinusValidationError" }

// Error satisfies the builtin error interface
func (e FocusStepMinusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFocusStepMinus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FocusStepMinusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FocusStepMinusValidationError{}

// Validate checks the field values on Calibrate with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Calibrate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Calibrate with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CalibrateMultiError, or nil
// if none found.
func (m *Calibrate) ValidateAll() error {
	return m.validate(true)
}

func (m *Calibrate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return CalibrateMultiError(errors)
	}

	return nil
}

// CalibrateMultiError is an error wrapping multiple validation errors returned
// by Calibrate.ValidateAll() if the designated constraints aren't met.
type CalibrateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CalibrateMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CalibrateMultiError) AllErrors() []error { return m }

// CalibrateValidationError is the validation error returned by
// Calibrate.Validate if the designated constraints aren't met.
type CalibrateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CalibrateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CalibrateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CalibrateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CalibrateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CalibrateValidationError) ErrorName() string { return "CalibrateValidationError" }

// Error satisfies the builtin error interface
func (e CalibrateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCalibrate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CalibrateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CalibrateValidationError{}

// Validate checks the field values on Zoom with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Zoom) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Zoom with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ZoomMultiError, or nil if none found.
func (m *Zoom) ValidateAll() error {
	return m.validate(true)
}

func (m *Zoom) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Cmd.(type) {
	case *Zoom_SetZoomTableValue:
		if v == nil {
			err := ZoomValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetZoomTableValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ZoomValidationError{
						field:  "SetZoomTableValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ZoomValidationError{
						field:  "SetZoomTableValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetZoomTableValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ZoomValidationError{
					field:  "SetZoomTableValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Zoom_NextZoomTablePos:
		if v == nil {
			err := ZoomValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetNextZoomTablePos()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ZoomValidationError{
						field:  "NextZoomTablePos",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ZoomValidationError{
						field:  "NextZoomTablePos",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetNextZoomTablePos()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ZoomValidationError{
					field:  "NextZoomTablePos",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Zoom_PrevZoomTablePos:
		if v == nil {
			err := ZoomValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetPrevZoomTablePos()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ZoomValidationError{
						field:  "PrevZoomTablePos",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ZoomValidationError{
						field:  "PrevZoomTablePos",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetPrevZoomTablePos()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ZoomValidationError{
					field:  "PrevZoomTablePos",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ZoomMultiError(errors)
	}

	return nil
}

// ZoomMultiError is an error wrapping multiple validation errors returned by
// Zoom.ValidateAll() if the designated constraints aren't met.
type ZoomMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ZoomMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ZoomMultiError) AllErrors() []error { return m }

// ZoomValidationError is the validation error returned by Zoom.Validate if the
// designated constraints aren't met.
type ZoomValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ZoomValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ZoomValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ZoomValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ZoomValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ZoomValidationError) ErrorName() string { return "ZoomValidationError" }

// Error satisfies the builtin error interface
func (e ZoomValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sZoom.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ZoomValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ZoomValidationError{}

// Validate checks the field values on NextZoomTablePos with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *NextZoomTablePos) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NextZoomTablePos with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NextZoomTablePosMultiError, or nil if none found.
func (m *NextZoomTablePos) ValidateAll() error {
	return m.validate(true)
}

func (m *NextZoomTablePos) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return NextZoomTablePosMultiError(errors)
	}

	return nil
}

// NextZoomTablePosMultiError is an error wrapping multiple validation errors
// returned by NextZoomTablePos.ValidateAll() if the designated constraints
// aren't met.
type NextZoomTablePosMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NextZoomTablePosMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NextZoomTablePosMultiError) AllErrors() []error { return m }

// NextZoomTablePosValidationError is the validation error returned by
// NextZoomTablePos.Validate if the designated constraints aren't met.
type NextZoomTablePosValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NextZoomTablePosValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NextZoomTablePosValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NextZoomTablePosValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NextZoomTablePosValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NextZoomTablePosValidationError) ErrorName() string { return "NextZoomTablePosValidationError" }

// Error satisfies the builtin error interface
func (e NextZoomTablePosValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNextZoomTablePos.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NextZoomTablePosValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NextZoomTablePosValidationError{}

// Validate checks the field values on PrevZoomTablePos with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PrevZoomTablePos) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PrevZoomTablePos with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PrevZoomTablePosMultiError, or nil if none found.
func (m *PrevZoomTablePos) ValidateAll() error {
	return m.validate(true)
}

func (m *PrevZoomTablePos) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PrevZoomTablePosMultiError(errors)
	}

	return nil
}

// PrevZoomTablePosMultiError is an error wrapping multiple validation errors
// returned by PrevZoomTablePos.ValidateAll() if the designated constraints
// aren't met.
type PrevZoomTablePosMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PrevZoomTablePosMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PrevZoomTablePosMultiError) AllErrors() []error { return m }

// PrevZoomTablePosValidationError is the validation error returned by
// PrevZoomTablePos.Validate if the designated constraints aren't met.
type PrevZoomTablePosValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PrevZoomTablePosValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PrevZoomTablePosValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PrevZoomTablePosValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PrevZoomTablePosValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PrevZoomTablePosValidationError) ErrorName() string { return "PrevZoomTablePosValidationError" }

// Error satisfies the builtin error interface
func (e PrevZoomTablePosValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPrevZoomTablePos.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PrevZoomTablePosValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PrevZoomTablePosValidationError{}

// Validate checks the field values on SetCalibMode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetCalibMode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetCalibMode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SetCalibModeMultiError, or
// nil if none found.
func (m *SetCalibMode) ValidateAll() error {
	return m.validate(true)
}

func (m *SetCalibMode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SetCalibModeMultiError(errors)
	}

	return nil
}

// SetCalibModeMultiError is an error wrapping multiple validation errors
// returned by SetCalibMode.ValidateAll() if the designated constraints aren't met.
type SetCalibModeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetCalibModeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetCalibModeMultiError) AllErrors() []error { return m }

// SetCalibModeValidationError is the validation error returned by
// SetCalibMode.Validate if the designated constraints aren't met.
type SetCalibModeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetCalibModeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetCalibModeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetCalibModeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetCalibModeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetCalibModeValidationError) ErrorName() string { return "SetCalibModeValidationError" }

// Error satisfies the builtin error interface
func (e SetCalibModeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetCalibMode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetCalibModeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetCalibModeValidationError{}

// Validate checks the field values on SetZoomTableValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SetZoomTableValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetZoomTableValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetZoomTableValueMultiError, or nil if none found.
func (m *SetZoomTableValue) ValidateAll() error {
	return m.validate(true)
}

func (m *SetZoomTableValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SetZoomTableValueMultiError(errors)
	}

	return nil
}

// SetZoomTableValueMultiError is an error wrapping multiple validation errors
// returned by SetZoomTableValue.ValidateAll() if the designated constraints
// aren't met.
type SetZoomTableValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetZoomTableValueMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetZoomTableValueMultiError) AllErrors() []error { return m }

// SetZoomTableValueValidationError is the validation error returned by
// SetZoomTableValue.Validate if the designated constraints aren't met.
type SetZoomTableValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetZoomTableValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetZoomTableValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetZoomTableValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetZoomTableValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetZoomTableValueValidationError) ErrorName() string {
	return "SetZoomTableValueValidationError"
}

// Error satisfies the builtin error interface
func (e SetZoomTableValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetZoomTableValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetZoomTableValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetZoomTableValueValidationError{}

// Validate checks the field values on SetAGC with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetAGC) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetAGC with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SetAGCMultiError, or nil if none found.
func (m *SetAGC) ValidateAll() error {
	return m.validate(true)
}

func (m *SetAGC) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SetAGCMultiError(errors)
	}

	return nil
}

// SetAGCMultiError is an error wrapping multiple validation errors returned by
// SetAGC.ValidateAll() if the designated constraints aren't met.
type SetAGCMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetAGCMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetAGCMultiError) AllErrors() []error { return m }

// SetAGCValidationError is the validation error returned by SetAGC.Validate if
// the designated constraints aren't met.
type SetAGCValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetAGCValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetAGCValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetAGCValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetAGCValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetAGCValidationError) ErrorName() string { return "SetAGCValidationError" }

// Error satisfies the builtin error interface
func (e SetAGCValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetAGC.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetAGCValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetAGCValidationError{}

// Validate checks the field values on SetFilters with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetFilters) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetFilters with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SetFiltersMultiError, or
// nil if none found.
func (m *SetFilters) ValidateAll() error {
	return m.validate(true)
}

func (m *SetFilters) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SetFiltersMultiError(errors)
	}

	return nil
}

// SetFiltersMultiError is an error wrapping multiple validation errors
// returned by SetFilters.ValidateAll() if the designated constraints aren't met.
type SetFiltersMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetFiltersMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetFiltersMultiError) AllErrors() []error { return m }

// SetFiltersValidationError is the validation error returned by
// SetFilters.Validate if the designated constraints aren't met.
type SetFiltersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetFiltersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetFiltersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetFiltersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetFiltersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetFiltersValidationError) ErrorName() string { return "SetFiltersValidationError" }

// Error satisfies the builtin error interface
func (e SetFiltersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetFilters.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetFiltersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetFiltersValidationError{}

// Validate checks the field values on Start with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Start) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Start with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StartMultiError, or nil if none found.
func (m *Start) ValidateAll() error {
	return m.validate(true)
}

func (m *Start) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return StartMultiError(errors)
	}

	return nil
}

// StartMultiError is an error wrapping multiple validation errors returned by
// Start.ValidateAll() if the designated constraints aren't met.
type StartMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartMultiError) AllErrors() []error { return m }

// StartValidationError is the validation error returned by Start.Validate if
// the designated constraints aren't met.
type StartValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartValidationError) ErrorName() string { return "StartValidationError" }

// Error satisfies the builtin error interface
func (e StartValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStart.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartValidationError{}

// Validate checks the field values on Stop with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Stop) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Stop with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StopMultiError, or nil if none found.
func (m *Stop) ValidateAll() error {
	return m.validate(true)
}

func (m *Stop) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return StopMultiError(errors)
	}

	return nil
}

// StopMultiError is an error wrapping multiple validation errors returned by
// Stop.ValidateAll() if the designated constraints aren't met.
type StopMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopMultiError) AllErrors() []error { return m }

// StopValidationError is the validation error returned by Stop.Validate if the
// designated constraints aren't met.
type StopValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopValidationError) ErrorName() string { return "StopValidationError" }

// Error satisfies the builtin error interface
func (e StopValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStop.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopValidationError{}

// Validate checks the field values on Halt with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Halt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Halt with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in HaltMultiError, or nil if none found.
func (m *Halt) ValidateAll() error {
	return m.validate(true)
}

func (m *Halt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return HaltMultiError(errors)
	}

	return nil
}

// HaltMultiError is an error wrapping multiple validation errors returned by
// Halt.ValidateAll() if the designated constraints aren't met.
type HaltMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HaltMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HaltMultiError) AllErrors() []error { return m }

// HaltValidationError is the validation error returned by Halt.Validate if the
// designated constraints aren't met.
type HaltValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HaltValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HaltValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HaltValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HaltValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HaltValidationError) ErrorName() string { return "HaltValidationError" }

// Error satisfies the builtin error interface
func (e HaltValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHalt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HaltValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HaltValidationError{}

// Validate checks the field values on Photo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Photo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Photo with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PhotoMultiError, or nil if none found.
func (m *Photo) ValidateAll() error {
	return m.validate(true)
}

func (m *Photo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PhotoMultiError(errors)
	}

	return nil
}

// PhotoMultiError is an error wrapping multiple validation errors returned by
// Photo.ValidateAll() if the designated constraints aren't met.
type PhotoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PhotoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PhotoMultiError) AllErrors() []error { return m }

// PhotoValidationError is the validation error returned by Photo.Validate if
// the designated constraints aren't met.
type PhotoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PhotoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PhotoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PhotoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PhotoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PhotoValidationError) ErrorName() string { return "PhotoValidationError" }

// Error satisfies the builtin error interface
func (e PhotoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPhoto.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PhotoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PhotoValidationError{}

// Validate checks the field values on GetMeteo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetMeteo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMeteo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetMeteoMultiError, or nil
// if none found.
func (m *GetMeteo) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMeteo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetMeteoMultiError(errors)
	}

	return nil
}

// GetMeteoMultiError is an error wrapping multiple validation errors returned
// by GetMeteo.ValidateAll() if the designated constraints aren't met.
type GetMeteoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMeteoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMeteoMultiError) AllErrors() []error { return m }

// GetMeteoValidationError is the validation error returned by
// GetMeteo.Validate if the designated constraints aren't met.
type GetMeteoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMeteoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMeteoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMeteoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMeteoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMeteoValidationError) ErrorName() string { return "GetMeteoValidationError" }

// Error satisfies the builtin error interface
func (e GetMeteoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMeteo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMeteoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMeteoValidationError{}

// Validate checks the field values on SetAutoFocus with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetAutoFocus) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetAutoFocus with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SetAutoFocusMultiError, or
// nil if none found.
func (m *SetAutoFocus) ValidateAll() error {
	return m.validate(true)
}

func (m *SetAutoFocus) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SetAutoFocusMultiError(errors)
	}

	return nil
}

// SetAutoFocusMultiError is an error wrapping multiple validation errors
// returned by SetAutoFocus.ValidateAll() if the designated constraints aren't met.
type SetAutoFocusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetAutoFocusMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetAutoFocusMultiError) AllErrors() []error { return m }

// SetAutoFocusValidationError is the validation error returned by
// SetAutoFocus.Validate if the designated constraints aren't met.
type SetAutoFocusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetAutoFocusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetAutoFocusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetAutoFocusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetAutoFocusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetAutoFocusValidationError) ErrorName() string { return "SetAutoFocusValidationError" }

// Error satisfies the builtin error interface
func (e SetAutoFocusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetAutoFocus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetAutoFocusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetAutoFocusValidationError{}

// Validate checks the field values on ResetZoom with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResetZoom) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResetZoom with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResetZoomMultiError, or nil
// if none found.
func (m *ResetZoom) ValidateAll() error {
	return m.validate(true)
}

func (m *ResetZoom) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ResetZoomMultiError(errors)
	}

	return nil
}

// ResetZoomMultiError is an error wrapping multiple validation errors returned
// by ResetZoom.ValidateAll() if the designated constraints aren't met.
type ResetZoomMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResetZoomMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResetZoomMultiError) AllErrors() []error { return m }

// ResetZoomValidationError is the validation error returned by
// ResetZoom.Validate if the designated constraints aren't met.
type ResetZoomValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResetZoomValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResetZoomValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResetZoomValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResetZoomValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResetZoomValidationError) ErrorName() string { return "ResetZoomValidationError" }

// Error satisfies the builtin error interface
func (e ResetZoomValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResetZoom.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResetZoomValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResetZoomValidationError{}

// Validate checks the field values on SaveToTable with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SaveToTable) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SaveToTable with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SaveToTableMultiError, or
// nil if none found.
func (m *SaveToTable) ValidateAll() error {
	return m.validate(true)
}

func (m *SaveToTable) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SaveToTableMultiError(errors)
	}

	return nil
}

// SaveToTableMultiError is an error wrapping multiple validation errors
// returned by SaveToTable.ValidateAll() if the designated constraints aren't met.
type SaveToTableMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SaveToTableMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SaveToTableMultiError) AllErrors() []error { return m }

// SaveToTableValidationError is the validation error returned by
// SaveToTable.Validate if the designated constraints aren't met.
type SaveToTableValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SaveToTableValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SaveToTableValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SaveToTableValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SaveToTableValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SaveToTableValidationError) ErrorName() string { return "SaveToTableValidationError" }

// Error satisfies the builtin error interface
func (e SaveToTableValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSaveToTable.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SaveToTableValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SaveToTableValidationError{}
