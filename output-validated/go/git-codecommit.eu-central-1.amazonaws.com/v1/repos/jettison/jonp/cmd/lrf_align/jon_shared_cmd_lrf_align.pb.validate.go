// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: jon_shared_cmd_lrf_align.proto

package lrf_align

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Root with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Root) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Root with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RootMultiError, or nil if none found.
func (m *Root) ValidateAll() error {
	return m.validate(true)
}

func (m *Root) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Channel.(type) {
	case *Root_Day:
		if v == nil {
			err := RootValidationError{
				field:  "Channel",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetDay()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Day",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Day",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetDay()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "Day",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_Heat:
		if v == nil {
			err := RootValidationError{
				field:  "Channel",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHeat()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Heat",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Heat",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHeat()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "Heat",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return RootMultiError(errors)
	}

	return nil
}

// RootMultiError is an error wrapping multiple validation errors returned by
// Root.ValidateAll() if the designated constraints aren't met.
type RootMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RootMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RootMultiError) AllErrors() []error { return m }

// RootValidationError is the validation error returned by Root.Validate if the
// designated constraints aren't met.
type RootValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RootValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RootValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RootValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RootValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RootValidationError) ErrorName() string { return "RootValidationError" }

// Error satisfies the builtin error interface
func (e RootValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RootValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RootValidationError{}

// Validate checks the field values on Offsets with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Offsets) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Offsets with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in OffsetsMultiError, or nil if none found.
func (m *Offsets) ValidateAll() error {
	return m.validate(true)
}

func (m *Offsets) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Cmd.(type) {
	case *Offsets_Set:
		if v == nil {
			err := OffsetsValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSet()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OffsetsValidationError{
						field:  "Set",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OffsetsValidationError{
						field:  "Set",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSet()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OffsetsValidationError{
					field:  "Set",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Offsets_Save:
		if v == nil {
			err := OffsetsValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSave()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OffsetsValidationError{
						field:  "Save",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OffsetsValidationError{
						field:  "Save",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSave()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OffsetsValidationError{
					field:  "Save",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Offsets_Reset_:
		if v == nil {
			err := OffsetsValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetReset_()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OffsetsValidationError{
						field:  "Reset_",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OffsetsValidationError{
						field:  "Reset_",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetReset_()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OffsetsValidationError{
					field:  "Reset_",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Offsets_Shift:
		if v == nil {
			err := OffsetsValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetShift()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, OffsetsValidationError{
						field:  "Shift",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, OffsetsValidationError{
						field:  "Shift",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetShift()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return OffsetsValidationError{
					field:  "Shift",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return OffsetsMultiError(errors)
	}

	return nil
}

// OffsetsMultiError is an error wrapping multiple validation errors returned
// by Offsets.ValidateAll() if the designated constraints aren't met.
type OffsetsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OffsetsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OffsetsMultiError) AllErrors() []error { return m }

// OffsetsValidationError is the validation error returned by Offsets.Validate
// if the designated constraints aren't met.
type OffsetsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OffsetsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OffsetsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OffsetsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OffsetsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OffsetsValidationError) ErrorName() string { return "OffsetsValidationError" }

// Error satisfies the builtin error interface
func (e OffsetsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOffsets.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OffsetsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OffsetsValidationError{}

// Validate checks the field values on SetOffsets with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetOffsets) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetOffsets with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SetOffsetsMultiError, or
// nil if none found.
func (m *SetOffsets) ValidateAll() error {
	return m.validate(true)
}

func (m *SetOffsets) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for X

	// no validation rules for Y

	if len(errors) > 0 {
		return SetOffsetsMultiError(errors)
	}

	return nil
}

// SetOffsetsMultiError is an error wrapping multiple validation errors
// returned by SetOffsets.ValidateAll() if the designated constraints aren't met.
type SetOffsetsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetOffsetsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetOffsetsMultiError) AllErrors() []error { return m }

// SetOffsetsValidationError is the validation error returned by
// SetOffsets.Validate if the designated constraints aren't met.
type SetOffsetsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetOffsetsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetOffsetsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetOffsetsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetOffsetsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetOffsetsValidationError) ErrorName() string { return "SetOffsetsValidationError" }

// Error satisfies the builtin error interface
func (e SetOffsetsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetOffsets.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetOffsetsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetOffsetsValidationError{}

// Validate checks the field values on ShiftOffsetsBy with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ShiftOffsetsBy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ShiftOffsetsBy with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ShiftOffsetsByMultiError,
// or nil if none found.
func (m *ShiftOffsetsBy) ValidateAll() error {
	return m.validate(true)
}

func (m *ShiftOffsetsBy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for X

	// no validation rules for Y

	if len(errors) > 0 {
		return ShiftOffsetsByMultiError(errors)
	}

	return nil
}

// ShiftOffsetsByMultiError is an error wrapping multiple validation errors
// returned by ShiftOffsetsBy.ValidateAll() if the designated constraints
// aren't met.
type ShiftOffsetsByMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ShiftOffsetsByMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ShiftOffsetsByMultiError) AllErrors() []error { return m }

// ShiftOffsetsByValidationError is the validation error returned by
// ShiftOffsetsBy.Validate if the designated constraints aren't met.
type ShiftOffsetsByValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ShiftOffsetsByValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ShiftOffsetsByValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ShiftOffsetsByValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ShiftOffsetsByValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ShiftOffsetsByValidationError) ErrorName() string { return "ShiftOffsetsByValidationError" }

// Error satisfies the builtin error interface
func (e ShiftOffsetsByValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sShiftOffsetsBy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ShiftOffsetsByValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ShiftOffsetsByValidationError{}

// Validate checks the field values on ResetOffsets with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ResetOffsets) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResetOffsets with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ResetOffsetsMultiError, or
// nil if none found.
func (m *ResetOffsets) ValidateAll() error {
	return m.validate(true)
}

func (m *ResetOffsets) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ResetOffsetsMultiError(errors)
	}

	return nil
}

// ResetOffsetsMultiError is an error wrapping multiple validation errors
// returned by ResetOffsets.ValidateAll() if the designated constraints aren't met.
type ResetOffsetsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResetOffsetsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResetOffsetsMultiError) AllErrors() []error { return m }

// ResetOffsetsValidationError is the validation error returned by
// ResetOffsets.Validate if the designated constraints aren't met.
type ResetOffsetsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResetOffsetsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResetOffsetsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResetOffsetsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResetOffsetsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResetOffsetsValidationError) ErrorName() string { return "ResetOffsetsValidationError" }

// Error satisfies the builtin error interface
func (e ResetOffsetsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResetOffsets.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResetOffsetsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResetOffsetsValidationError{}

// Validate checks the field values on SaveOffsets with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SaveOffsets) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SaveOffsets with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SaveOffsetsMultiError, or
// nil if none found.
func (m *SaveOffsets) ValidateAll() error {
	return m.validate(true)
}

func (m *SaveOffsets) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SaveOffsetsMultiError(errors)
	}

	return nil
}

// SaveOffsetsMultiError is an error wrapping multiple validation errors
// returned by SaveOffsets.ValidateAll() if the designated constraints aren't met.
type SaveOffsetsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SaveOffsetsMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SaveOffsetsMultiError) AllErrors() []error { return m }

// SaveOffsetsValidationError is the validation error returned by
// SaveOffsets.Validate if the designated constraints aren't met.
type SaveOffsetsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SaveOffsetsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SaveOffsetsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SaveOffsetsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SaveOffsetsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SaveOffsetsValidationError) ErrorName() string { return "SaveOffsetsValidationError" }

// Error satisfies the builtin error interface
func (e SaveOffsetsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSaveOffsets.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SaveOffsetsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SaveOffsetsValidationError{}
