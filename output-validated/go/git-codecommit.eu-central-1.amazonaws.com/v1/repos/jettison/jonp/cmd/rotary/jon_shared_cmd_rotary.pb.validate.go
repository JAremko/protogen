// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: jon_shared_cmd_rotary.proto

package rotary

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	types "git-codecommit.eu-central-1.amazonaws.com/v1/repos/jettison/jonp/types"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = types.JonGuiDataRotaryMode(0)
)

// Validate checks the field values on Root with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Root) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Root with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RootMultiError, or nil if none found.
func (m *Root) ValidateAll() error {
	return m.validate(true)
}

func (m *Root) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Cmd.(type) {
	case *Root_Start:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStart()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Start",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Start",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStart()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "Start",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_Stop:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetStop()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Stop",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Stop",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetStop()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "Stop",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_Axis:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetAxis()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Axis",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Axis",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetAxis()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "Axis",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_SetPlatformAzimuth:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetPlatformAzimuth()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetPlatformAzimuth",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetPlatformAzimuth",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetPlatformAzimuth()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "SetPlatformAzimuth",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_SetPlatformElevation:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetPlatformElevation()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetPlatformElevation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetPlatformElevation",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetPlatformElevation()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "SetPlatformElevation",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_SetPlatformBank:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetPlatformBank()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetPlatformBank",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetPlatformBank",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetPlatformBank()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "SetPlatformBank",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_Halt:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHalt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Halt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "Halt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHalt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "Halt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_SetUseRotaryAsCompass:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetUseRotaryAsCompass()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetUseRotaryAsCompass",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetUseRotaryAsCompass",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetUseRotaryAsCompass()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "SetUseRotaryAsCompass",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_RotateToGps:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRotateToGps()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "RotateToGps",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "RotateToGps",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRotateToGps()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "RotateToGps",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_SetOriginGps:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetOriginGps()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetOriginGps",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetOriginGps",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetOriginGps()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "SetOriginGps",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_SetMode:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetMode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetMode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "SetMode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetMode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "SetMode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_RotateToNdc:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRotateToNdc()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "RotateToNdc",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "RotateToNdc",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRotateToNdc()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "RotateToNdc",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_ScanStart:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetScanStart()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanStart",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanStart",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetScanStart()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "ScanStart",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_ScanStop:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetScanStop()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanStop",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanStop",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetScanStop()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "ScanStop",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_ScanPause:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetScanPause()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanPause",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanPause",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetScanPause()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "ScanPause",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_ScanUnpause:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetScanUnpause()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanUnpause",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanUnpause",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetScanUnpause()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "ScanUnpause",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_GetMeteo:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetGetMeteo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "GetMeteo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "GetMeteo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetGetMeteo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "GetMeteo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_ScanPrev:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetScanPrev()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanPrev",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanPrev",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetScanPrev()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "ScanPrev",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_ScanNext:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetScanNext()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanNext",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanNext",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetScanNext()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "ScanNext",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_ScanRefreshNodeList:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetScanRefreshNodeList()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanRefreshNodeList",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanRefreshNodeList",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetScanRefreshNodeList()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "ScanRefreshNodeList",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_ScanSelectNode:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetScanSelectNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanSelectNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanSelectNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetScanSelectNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "ScanSelectNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_ScanDeleteNode:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetScanDeleteNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanDeleteNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanDeleteNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetScanDeleteNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "ScanDeleteNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_ScanUpdateNode:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetScanUpdateNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanUpdateNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanUpdateNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetScanUpdateNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "ScanUpdateNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Root_ScanAddNode:
		if v == nil {
			err := RootValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetScanAddNode()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanAddNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RootValidationError{
						field:  "ScanAddNode",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetScanAddNode()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RootValidationError{
					field:  "ScanAddNode",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return RootMultiError(errors)
	}

	return nil
}

// RootMultiError is an error wrapping multiple validation errors returned by
// Root.ValidateAll() if the designated constraints aren't met.
type RootMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RootMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RootMultiError) AllErrors() []error { return m }

// RootValidationError is the validation error returned by Root.Validate if the
// designated constraints aren't met.
type RootValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RootValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RootValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RootValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RootValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RootValidationError) ErrorName() string { return "RootValidationError" }

// Error satisfies the builtin error interface
func (e RootValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRoot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RootValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RootValidationError{}

// Validate checks the field values on Axis with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Axis) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Axis with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AxisMultiError, or nil if none found.
func (m *Axis) ValidateAll() error {
	return m.validate(true)
}

func (m *Axis) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetAzimuth()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AxisValidationError{
					field:  "Azimuth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AxisValidationError{
					field:  "Azimuth",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAzimuth()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AxisValidationError{
				field:  "Azimuth",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetElevation()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AxisValidationError{
					field:  "Elevation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AxisValidationError{
					field:  "Elevation",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetElevation()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AxisValidationError{
				field:  "Elevation",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AxisMultiError(errors)
	}

	return nil
}

// AxisMultiError is an error wrapping multiple validation errors returned by
// Axis.ValidateAll() if the designated constraints aren't met.
type AxisMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AxisMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AxisMultiError) AllErrors() []error { return m }

// AxisValidationError is the validation error returned by Axis.Validate if the
// designated constraints aren't met.
type AxisValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AxisValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AxisValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AxisValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AxisValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AxisValidationError) ErrorName() string { return "AxisValidationError" }

// Error satisfies the builtin error interface
func (e AxisValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAxis.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AxisValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AxisValidationError{}

// Validate checks the field values on SetMode with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetMode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetMode with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in SetModeMultiError, or nil if none found.
func (m *SetMode) ValidateAll() error {
	return m.validate(true)
}

func (m *SetMode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Mode

	if len(errors) > 0 {
		return SetModeMultiError(errors)
	}

	return nil
}

// SetModeMultiError is an error wrapping multiple validation errors returned
// by SetMode.ValidateAll() if the designated constraints aren't met.
type SetModeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetModeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetModeMultiError) AllErrors() []error { return m }

// SetModeValidationError is the validation error returned by SetMode.Validate
// if the designated constraints aren't met.
type SetModeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetModeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetModeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetModeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetModeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetModeValidationError) ErrorName() string { return "SetModeValidationError" }

// Error satisfies the builtin error interface
func (e SetModeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetMode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetModeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetModeValidationError{}

// Validate checks the field values on SetAzimuthValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SetAzimuthValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetAzimuthValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetAzimuthValueMultiError, or nil if none found.
func (m *SetAzimuthValue) ValidateAll() error {
	return m.validate(true)
}

func (m *SetAzimuthValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	// no validation rules for Direction

	if len(errors) > 0 {
		return SetAzimuthValueMultiError(errors)
	}

	return nil
}

// SetAzimuthValueMultiError is an error wrapping multiple validation errors
// returned by SetAzimuthValue.ValidateAll() if the designated constraints
// aren't met.
type SetAzimuthValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetAzimuthValueMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetAzimuthValueMultiError) AllErrors() []error { return m }

// SetAzimuthValueValidationError is the validation error returned by
// SetAzimuthValue.Validate if the designated constraints aren't met.
type SetAzimuthValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetAzimuthValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetAzimuthValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetAzimuthValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetAzimuthValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetAzimuthValueValidationError) ErrorName() string { return "SetAzimuthValueValidationError" }

// Error satisfies the builtin error interface
func (e SetAzimuthValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetAzimuthValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetAzimuthValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetAzimuthValueValidationError{}

// Validate checks the field values on RotateAzimuthTo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RotateAzimuthTo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RotateAzimuthTo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RotateAzimuthToMultiError, or nil if none found.
func (m *RotateAzimuthTo) ValidateAll() error {
	return m.validate(true)
}

func (m *RotateAzimuthTo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TargetValue

	// no validation rules for Speed

	// no validation rules for Direction

	if len(errors) > 0 {
		return RotateAzimuthToMultiError(errors)
	}

	return nil
}

// RotateAzimuthToMultiError is an error wrapping multiple validation errors
// returned by RotateAzimuthTo.ValidateAll() if the designated constraints
// aren't met.
type RotateAzimuthToMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RotateAzimuthToMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RotateAzimuthToMultiError) AllErrors() []error { return m }

// RotateAzimuthToValidationError is the validation error returned by
// RotateAzimuthTo.Validate if the designated constraints aren't met.
type RotateAzimuthToValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RotateAzimuthToValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RotateAzimuthToValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RotateAzimuthToValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RotateAzimuthToValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RotateAzimuthToValidationError) ErrorName() string { return "RotateAzimuthToValidationError" }

// Error satisfies the builtin error interface
func (e RotateAzimuthToValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRotateAzimuthTo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RotateAzimuthToValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RotateAzimuthToValidationError{}

// Validate checks the field values on RotateAzimuth with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RotateAzimuth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RotateAzimuth with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RotateAzimuthMultiError, or
// nil if none found.
func (m *RotateAzimuth) ValidateAll() error {
	return m.validate(true)
}

func (m *RotateAzimuth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Speed

	// no validation rules for Direction

	if len(errors) > 0 {
		return RotateAzimuthMultiError(errors)
	}

	return nil
}

// RotateAzimuthMultiError is an error wrapping multiple validation errors
// returned by RotateAzimuth.ValidateAll() if the designated constraints
// aren't met.
type RotateAzimuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RotateAzimuthMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RotateAzimuthMultiError) AllErrors() []error { return m }

// RotateAzimuthValidationError is the validation error returned by
// RotateAzimuth.Validate if the designated constraints aren't met.
type RotateAzimuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RotateAzimuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RotateAzimuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RotateAzimuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RotateAzimuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RotateAzimuthValidationError) ErrorName() string { return "RotateAzimuthValidationError" }

// Error satisfies the builtin error interface
func (e RotateAzimuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRotateAzimuth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RotateAzimuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RotateAzimuthValidationError{}

// Validate checks the field values on RotateElevation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RotateElevation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RotateElevation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RotateElevationMultiError, or nil if none found.
func (m *RotateElevation) ValidateAll() error {
	return m.validate(true)
}

func (m *RotateElevation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Speed

	// no validation rules for Direction

	if len(errors) > 0 {
		return RotateElevationMultiError(errors)
	}

	return nil
}

// RotateElevationMultiError is an error wrapping multiple validation errors
// returned by RotateElevation.ValidateAll() if the designated constraints
// aren't met.
type RotateElevationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RotateElevationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RotateElevationMultiError) AllErrors() []error { return m }

// RotateElevationValidationError is the validation error returned by
// RotateElevation.Validate if the designated constraints aren't met.
type RotateElevationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RotateElevationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RotateElevationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RotateElevationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RotateElevationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RotateElevationValidationError) ErrorName() string { return "RotateElevationValidationError" }

// Error satisfies the builtin error interface
func (e RotateElevationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRotateElevation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RotateElevationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RotateElevationValidationError{}

// Validate checks the field values on SetElevationValue with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SetElevationValue) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetElevationValue with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetElevationValueMultiError, or nil if none found.
func (m *SetElevationValue) ValidateAll() error {
	return m.validate(true)
}

func (m *SetElevationValue) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SetElevationValueMultiError(errors)
	}

	return nil
}

// SetElevationValueMultiError is an error wrapping multiple validation errors
// returned by SetElevationValue.ValidateAll() if the designated constraints
// aren't met.
type SetElevationValueMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetElevationValueMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetElevationValueMultiError) AllErrors() []error { return m }

// SetElevationValueValidationError is the validation error returned by
// SetElevationValue.Validate if the designated constraints aren't met.
type SetElevationValueValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetElevationValueValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetElevationValueValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetElevationValueValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetElevationValueValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetElevationValueValidationError) ErrorName() string {
	return "SetElevationValueValidationError"
}

// Error satisfies the builtin error interface
func (e SetElevationValueValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetElevationValue.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetElevationValueValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetElevationValueValidationError{}

// Validate checks the field values on RotateElevationTo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RotateElevationTo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RotateElevationTo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RotateElevationToMultiError, or nil if none found.
func (m *RotateElevationTo) ValidateAll() error {
	return m.validate(true)
}

func (m *RotateElevationTo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TargetValue

	// no validation rules for Speed

	if len(errors) > 0 {
		return RotateElevationToMultiError(errors)
	}

	return nil
}

// RotateElevationToMultiError is an error wrapping multiple validation errors
// returned by RotateElevationTo.ValidateAll() if the designated constraints
// aren't met.
type RotateElevationToMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RotateElevationToMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RotateElevationToMultiError) AllErrors() []error { return m }

// RotateElevationToValidationError is the validation error returned by
// RotateElevationTo.Validate if the designated constraints aren't met.
type RotateElevationToValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RotateElevationToValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RotateElevationToValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RotateElevationToValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RotateElevationToValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RotateElevationToValidationError) ErrorName() string {
	return "RotateElevationToValidationError"
}

// Error satisfies the builtin error interface
func (e RotateElevationToValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRotateElevationTo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RotateElevationToValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RotateElevationToValidationError{}

// Validate checks the field values on RotateElevationRelative with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RotateElevationRelative) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RotateElevationRelative with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RotateElevationRelativeMultiError, or nil if none found.
func (m *RotateElevationRelative) ValidateAll() error {
	return m.validate(true)
}

func (m *RotateElevationRelative) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	// no validation rules for Speed

	// no validation rules for Direction

	if len(errors) > 0 {
		return RotateElevationRelativeMultiError(errors)
	}

	return nil
}

// RotateElevationRelativeMultiError is an error wrapping multiple validation
// errors returned by RotateElevationRelative.ValidateAll() if the designated
// constraints aren't met.
type RotateElevationRelativeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RotateElevationRelativeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RotateElevationRelativeMultiError) AllErrors() []error { return m }

// RotateElevationRelativeValidationError is the validation error returned by
// RotateElevationRelative.Validate if the designated constraints aren't met.
type RotateElevationRelativeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RotateElevationRelativeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RotateElevationRelativeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RotateElevationRelativeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RotateElevationRelativeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RotateElevationRelativeValidationError) ErrorName() string {
	return "RotateElevationRelativeValidationError"
}

// Error satisfies the builtin error interface
func (e RotateElevationRelativeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRotateElevationRelative.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RotateElevationRelativeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RotateElevationRelativeValidationError{}

// Validate checks the field values on RotateElevationRelativeSet with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RotateElevationRelativeSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RotateElevationRelativeSet with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RotateElevationRelativeSetMultiError, or nil if none found.
func (m *RotateElevationRelativeSet) ValidateAll() error {
	return m.validate(true)
}

func (m *RotateElevationRelativeSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	// no validation rules for Direction

	if len(errors) > 0 {
		return RotateElevationRelativeSetMultiError(errors)
	}

	return nil
}

// RotateElevationRelativeSetMultiError is an error wrapping multiple
// validation errors returned by RotateElevationRelativeSet.ValidateAll() if
// the designated constraints aren't met.
type RotateElevationRelativeSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RotateElevationRelativeSetMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RotateElevationRelativeSetMultiError) AllErrors() []error { return m }

// RotateElevationRelativeSetValidationError is the validation error returned
// by RotateElevationRelativeSet.Validate if the designated constraints aren't met.
type RotateElevationRelativeSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RotateElevationRelativeSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RotateElevationRelativeSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RotateElevationRelativeSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RotateElevationRelativeSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RotateElevationRelativeSetValidationError) ErrorName() string {
	return "RotateElevationRelativeSetValidationError"
}

// Error satisfies the builtin error interface
func (e RotateElevationRelativeSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRotateElevationRelativeSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RotateElevationRelativeSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RotateElevationRelativeSetValidationError{}

// Validate checks the field values on RotateAzimuthRelative with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RotateAzimuthRelative) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RotateAzimuthRelative with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RotateAzimuthRelativeMultiError, or nil if none found.
func (m *RotateAzimuthRelative) ValidateAll() error {
	return m.validate(true)
}

func (m *RotateAzimuthRelative) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	// no validation rules for Speed

	// no validation rules for Direction

	if len(errors) > 0 {
		return RotateAzimuthRelativeMultiError(errors)
	}

	return nil
}

// RotateAzimuthRelativeMultiError is an error wrapping multiple validation
// errors returned by RotateAzimuthRelative.ValidateAll() if the designated
// constraints aren't met.
type RotateAzimuthRelativeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RotateAzimuthRelativeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RotateAzimuthRelativeMultiError) AllErrors() []error { return m }

// RotateAzimuthRelativeValidationError is the validation error returned by
// RotateAzimuthRelative.Validate if the designated constraints aren't met.
type RotateAzimuthRelativeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RotateAzimuthRelativeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RotateAzimuthRelativeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RotateAzimuthRelativeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RotateAzimuthRelativeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RotateAzimuthRelativeValidationError) ErrorName() string {
	return "RotateAzimuthRelativeValidationError"
}

// Error satisfies the builtin error interface
func (e RotateAzimuthRelativeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRotateAzimuthRelative.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RotateAzimuthRelativeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RotateAzimuthRelativeValidationError{}

// Validate checks the field values on RotateAzimuthRelativeSet with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RotateAzimuthRelativeSet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RotateAzimuthRelativeSet with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RotateAzimuthRelativeSetMultiError, or nil if none found.
func (m *RotateAzimuthRelativeSet) ValidateAll() error {
	return m.validate(true)
}

func (m *RotateAzimuthRelativeSet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	// no validation rules for Direction

	if len(errors) > 0 {
		return RotateAzimuthRelativeSetMultiError(errors)
	}

	return nil
}

// RotateAzimuthRelativeSetMultiError is an error wrapping multiple validation
// errors returned by RotateAzimuthRelativeSet.ValidateAll() if the designated
// constraints aren't met.
type RotateAzimuthRelativeSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RotateAzimuthRelativeSetMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RotateAzimuthRelativeSetMultiError) AllErrors() []error { return m }

// RotateAzimuthRelativeSetValidationError is the validation error returned by
// RotateAzimuthRelativeSet.Validate if the designated constraints aren't met.
type RotateAzimuthRelativeSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RotateAzimuthRelativeSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RotateAzimuthRelativeSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RotateAzimuthRelativeSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RotateAzimuthRelativeSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RotateAzimuthRelativeSetValidationError) ErrorName() string {
	return "RotateAzimuthRelativeSetValidationError"
}

// Error satisfies the builtin error interface
func (e RotateAzimuthRelativeSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRotateAzimuthRelativeSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RotateAzimuthRelativeSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RotateAzimuthRelativeSetValidationError{}

// Validate checks the field values on SetPlatformAzimuth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetPlatformAzimuth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetPlatformAzimuth with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetPlatformAzimuthMultiError, or nil if none found.
func (m *SetPlatformAzimuth) ValidateAll() error {
	return m.validate(true)
}

func (m *SetPlatformAzimuth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SetPlatformAzimuthMultiError(errors)
	}

	return nil
}

// SetPlatformAzimuthMultiError is an error wrapping multiple validation errors
// returned by SetPlatformAzimuth.ValidateAll() if the designated constraints
// aren't met.
type SetPlatformAzimuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetPlatformAzimuthMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetPlatformAzimuthMultiError) AllErrors() []error { return m }

// SetPlatformAzimuthValidationError is the validation error returned by
// SetPlatformAzimuth.Validate if the designated constraints aren't met.
type SetPlatformAzimuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetPlatformAzimuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetPlatformAzimuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetPlatformAzimuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetPlatformAzimuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetPlatformAzimuthValidationError) ErrorName() string {
	return "SetPlatformAzimuthValidationError"
}

// Error satisfies the builtin error interface
func (e SetPlatformAzimuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetPlatformAzimuth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetPlatformAzimuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetPlatformAzimuthValidationError{}

// Validate checks the field values on SetPlatformElevation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetPlatformElevation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetPlatformElevation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetPlatformElevationMultiError, or nil if none found.
func (m *SetPlatformElevation) ValidateAll() error {
	return m.validate(true)
}

func (m *SetPlatformElevation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SetPlatformElevationMultiError(errors)
	}

	return nil
}

// SetPlatformElevationMultiError is an error wrapping multiple validation
// errors returned by SetPlatformElevation.ValidateAll() if the designated
// constraints aren't met.
type SetPlatformElevationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetPlatformElevationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetPlatformElevationMultiError) AllErrors() []error { return m }

// SetPlatformElevationValidationError is the validation error returned by
// SetPlatformElevation.Validate if the designated constraints aren't met.
type SetPlatformElevationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetPlatformElevationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetPlatformElevationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetPlatformElevationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetPlatformElevationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetPlatformElevationValidationError) ErrorName() string {
	return "SetPlatformElevationValidationError"
}

// Error satisfies the builtin error interface
func (e SetPlatformElevationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetPlatformElevation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetPlatformElevationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetPlatformElevationValidationError{}

// Validate checks the field values on SetPlatformBank with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SetPlatformBank) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetPlatformBank with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetPlatformBankMultiError, or nil if none found.
func (m *SetPlatformBank) ValidateAll() error {
	return m.validate(true)
}

func (m *SetPlatformBank) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Value

	if len(errors) > 0 {
		return SetPlatformBankMultiError(errors)
	}

	return nil
}

// SetPlatformBankMultiError is an error wrapping multiple validation errors
// returned by SetPlatformBank.ValidateAll() if the designated constraints
// aren't met.
type SetPlatformBankMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetPlatformBankMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetPlatformBankMultiError) AllErrors() []error { return m }

// SetPlatformBankValidationError is the validation error returned by
// SetPlatformBank.Validate if the designated constraints aren't met.
type SetPlatformBankValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetPlatformBankValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetPlatformBankValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetPlatformBankValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetPlatformBankValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetPlatformBankValidationError) ErrorName() string { return "SetPlatformBankValidationError" }

// Error satisfies the builtin error interface
func (e SetPlatformBankValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetPlatformBank.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetPlatformBankValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetPlatformBankValidationError{}

// Validate checks the field values on GetMeteo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetMeteo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetMeteo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetMeteoMultiError, or nil
// if none found.
func (m *GetMeteo) ValidateAll() error {
	return m.validate(true)
}

func (m *GetMeteo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetMeteoMultiError(errors)
	}

	return nil
}

// GetMeteoMultiError is an error wrapping multiple validation errors returned
// by GetMeteo.ValidateAll() if the designated constraints aren't met.
type GetMeteoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMeteoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMeteoMultiError) AllErrors() []error { return m }

// GetMeteoValidationError is the validation error returned by
// GetMeteo.Validate if the designated constraints aren't met.
type GetMeteoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMeteoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMeteoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMeteoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMeteoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMeteoValidationError) ErrorName() string { return "GetMeteoValidationError" }

// Error satisfies the builtin error interface
func (e GetMeteoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMeteo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMeteoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMeteoValidationError{}

// Validate checks the field values on Azimuth with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Azimuth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Azimuth with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AzimuthMultiError, or nil if none found.
func (m *Azimuth) ValidateAll() error {
	return m.validate(true)
}

func (m *Azimuth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Cmd.(type) {
	case *Azimuth_SetValue:
		if v == nil {
			err := AzimuthValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AzimuthValidationError{
						field:  "SetValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AzimuthValidationError{
						field:  "SetValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AzimuthValidationError{
					field:  "SetValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Azimuth_RotateTo:
		if v == nil {
			err := AzimuthValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRotateTo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AzimuthValidationError{
						field:  "RotateTo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AzimuthValidationError{
						field:  "RotateTo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRotateTo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AzimuthValidationError{
					field:  "RotateTo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Azimuth_Rotate:
		if v == nil {
			err := AzimuthValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRotate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AzimuthValidationError{
						field:  "Rotate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AzimuthValidationError{
						field:  "Rotate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRotate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AzimuthValidationError{
					field:  "Rotate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Azimuth_Relative:
		if v == nil {
			err := AzimuthValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRelative()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AzimuthValidationError{
						field:  "Relative",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AzimuthValidationError{
						field:  "Relative",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRelative()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AzimuthValidationError{
					field:  "Relative",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Azimuth_RelativeSet:
		if v == nil {
			err := AzimuthValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRelativeSet()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AzimuthValidationError{
						field:  "RelativeSet",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AzimuthValidationError{
						field:  "RelativeSet",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRelativeSet()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AzimuthValidationError{
					field:  "RelativeSet",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Azimuth_Halt:
		if v == nil {
			err := AzimuthValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHalt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AzimuthValidationError{
						field:  "Halt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AzimuthValidationError{
						field:  "Halt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHalt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AzimuthValidationError{
					field:  "Halt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return AzimuthMultiError(errors)
	}

	return nil
}

// AzimuthMultiError is an error wrapping multiple validation errors returned
// by Azimuth.ValidateAll() if the designated constraints aren't met.
type AzimuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AzimuthMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AzimuthMultiError) AllErrors() []error { return m }

// AzimuthValidationError is the validation error returned by Azimuth.Validate
// if the designated constraints aren't met.
type AzimuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AzimuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AzimuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AzimuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AzimuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AzimuthValidationError) ErrorName() string { return "AzimuthValidationError" }

// Error satisfies the builtin error interface
func (e AzimuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAzimuth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AzimuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AzimuthValidationError{}

// Validate checks the field values on Start with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Start) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Start with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StartMultiError, or nil if none found.
func (m *Start) ValidateAll() error {
	return m.validate(true)
}

func (m *Start) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return StartMultiError(errors)
	}

	return nil
}

// StartMultiError is an error wrapping multiple validation errors returned by
// Start.ValidateAll() if the designated constraints aren't met.
type StartMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StartMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StartMultiError) AllErrors() []error { return m }

// StartValidationError is the validation error returned by Start.Validate if
// the designated constraints aren't met.
type StartValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StartValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StartValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StartValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StartValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StartValidationError) ErrorName() string { return "StartValidationError" }

// Error satisfies the builtin error interface
func (e StartValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStart.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StartValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StartValidationError{}

// Validate checks the field values on Stop with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Stop) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Stop with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in StopMultiError, or nil if none found.
func (m *Stop) ValidateAll() error {
	return m.validate(true)
}

func (m *Stop) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return StopMultiError(errors)
	}

	return nil
}

// StopMultiError is an error wrapping multiple validation errors returned by
// Stop.ValidateAll() if the designated constraints aren't met.
type StopMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StopMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StopMultiError) AllErrors() []error { return m }

// StopValidationError is the validation error returned by Stop.Validate if the
// designated constraints aren't met.
type StopValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StopValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StopValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StopValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StopValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StopValidationError) ErrorName() string { return "StopValidationError" }

// Error satisfies the builtin error interface
func (e StopValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStop.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StopValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StopValidationError{}

// Validate checks the field values on Halt with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Halt) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Halt with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in HaltMultiError, or nil if none found.
func (m *Halt) ValidateAll() error {
	return m.validate(true)
}

func (m *Halt) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return HaltMultiError(errors)
	}

	return nil
}

// HaltMultiError is an error wrapping multiple validation errors returned by
// Halt.ValidateAll() if the designated constraints aren't met.
type HaltMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HaltMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HaltMultiError) AllErrors() []error { return m }

// HaltValidationError is the validation error returned by Halt.Validate if the
// designated constraints aren't met.
type HaltValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HaltValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HaltValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HaltValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HaltValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HaltValidationError) ErrorName() string { return "HaltValidationError" }

// Error satisfies the builtin error interface
func (e HaltValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHalt.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HaltValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HaltValidationError{}

// Validate checks the field values on ScanStart with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScanStart) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScanStart with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScanStartMultiError, or nil
// if none found.
func (m *ScanStart) ValidateAll() error {
	return m.validate(true)
}

func (m *ScanStart) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ScanStartMultiError(errors)
	}

	return nil
}

// ScanStartMultiError is an error wrapping multiple validation errors returned
// by ScanStart.ValidateAll() if the designated constraints aren't met.
type ScanStartMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScanStartMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScanStartMultiError) AllErrors() []error { return m }

// ScanStartValidationError is the validation error returned by
// ScanStart.Validate if the designated constraints aren't met.
type ScanStartValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScanStartValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScanStartValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScanStartValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScanStartValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScanStartValidationError) ErrorName() string { return "ScanStartValidationError" }

// Error satisfies the builtin error interface
func (e ScanStartValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScanStart.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScanStartValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScanStartValidationError{}

// Validate checks the field values on ScanStop with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScanStop) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScanStop with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScanStopMultiError, or nil
// if none found.
func (m *ScanStop) ValidateAll() error {
	return m.validate(true)
}

func (m *ScanStop) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ScanStopMultiError(errors)
	}

	return nil
}

// ScanStopMultiError is an error wrapping multiple validation errors returned
// by ScanStop.ValidateAll() if the designated constraints aren't met.
type ScanStopMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScanStopMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScanStopMultiError) AllErrors() []error { return m }

// ScanStopValidationError is the validation error returned by
// ScanStop.Validate if the designated constraints aren't met.
type ScanStopValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScanStopValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScanStopValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScanStopValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScanStopValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScanStopValidationError) ErrorName() string { return "ScanStopValidationError" }

// Error satisfies the builtin error interface
func (e ScanStopValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScanStop.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScanStopValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScanStopValidationError{}

// Validate checks the field values on ScanPause with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScanPause) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScanPause with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScanPauseMultiError, or nil
// if none found.
func (m *ScanPause) ValidateAll() error {
	return m.validate(true)
}

func (m *ScanPause) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ScanPauseMultiError(errors)
	}

	return nil
}

// ScanPauseMultiError is an error wrapping multiple validation errors returned
// by ScanPause.ValidateAll() if the designated constraints aren't met.
type ScanPauseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScanPauseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScanPauseMultiError) AllErrors() []error { return m }

// ScanPauseValidationError is the validation error returned by
// ScanPause.Validate if the designated constraints aren't met.
type ScanPauseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScanPauseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScanPauseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScanPauseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScanPauseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScanPauseValidationError) ErrorName() string { return "ScanPauseValidationError" }

// Error satisfies the builtin error interface
func (e ScanPauseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScanPause.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScanPauseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScanPauseValidationError{}

// Validate checks the field values on ScanUnpause with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScanUnpause) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScanUnpause with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScanUnpauseMultiError, or
// nil if none found.
func (m *ScanUnpause) ValidateAll() error {
	return m.validate(true)
}

func (m *ScanUnpause) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ScanUnpauseMultiError(errors)
	}

	return nil
}

// ScanUnpauseMultiError is an error wrapping multiple validation errors
// returned by ScanUnpause.ValidateAll() if the designated constraints aren't met.
type ScanUnpauseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScanUnpauseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScanUnpauseMultiError) AllErrors() []error { return m }

// ScanUnpauseValidationError is the validation error returned by
// ScanUnpause.Validate if the designated constraints aren't met.
type ScanUnpauseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScanUnpauseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScanUnpauseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScanUnpauseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScanUnpauseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScanUnpauseValidationError) ErrorName() string { return "ScanUnpauseValidationError" }

// Error satisfies the builtin error interface
func (e ScanUnpauseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScanUnpause.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScanUnpauseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScanUnpauseValidationError{}

// Validate checks the field values on HaltAzimuth with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HaltAzimuth) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HaltAzimuth with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HaltAzimuthMultiError, or
// nil if none found.
func (m *HaltAzimuth) ValidateAll() error {
	return m.validate(true)
}

func (m *HaltAzimuth) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return HaltAzimuthMultiError(errors)
	}

	return nil
}

// HaltAzimuthMultiError is an error wrapping multiple validation errors
// returned by HaltAzimuth.ValidateAll() if the designated constraints aren't met.
type HaltAzimuthMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HaltAzimuthMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HaltAzimuthMultiError) AllErrors() []error { return m }

// HaltAzimuthValidationError is the validation error returned by
// HaltAzimuth.Validate if the designated constraints aren't met.
type HaltAzimuthValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HaltAzimuthValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HaltAzimuthValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HaltAzimuthValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HaltAzimuthValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HaltAzimuthValidationError) ErrorName() string { return "HaltAzimuthValidationError" }

// Error satisfies the builtin error interface
func (e HaltAzimuthValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHaltAzimuth.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HaltAzimuthValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HaltAzimuthValidationError{}

// Validate checks the field values on HaltElevation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HaltElevation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HaltElevation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HaltElevationMultiError, or
// nil if none found.
func (m *HaltElevation) ValidateAll() error {
	return m.validate(true)
}

func (m *HaltElevation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return HaltElevationMultiError(errors)
	}

	return nil
}

// HaltElevationMultiError is an error wrapping multiple validation errors
// returned by HaltElevation.ValidateAll() if the designated constraints
// aren't met.
type HaltElevationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HaltElevationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HaltElevationMultiError) AllErrors() []error { return m }

// HaltElevationValidationError is the validation error returned by
// HaltElevation.Validate if the designated constraints aren't met.
type HaltElevationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HaltElevationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HaltElevationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HaltElevationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HaltElevationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HaltElevationValidationError) ErrorName() string { return "HaltElevationValidationError" }

// Error satisfies the builtin error interface
func (e HaltElevationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHaltElevation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HaltElevationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HaltElevationValidationError{}

// Validate checks the field values on ScanPrev with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScanPrev) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScanPrev with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScanPrevMultiError, or nil
// if none found.
func (m *ScanPrev) ValidateAll() error {
	return m.validate(true)
}

func (m *ScanPrev) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ScanPrevMultiError(errors)
	}

	return nil
}

// ScanPrevMultiError is an error wrapping multiple validation errors returned
// by ScanPrev.ValidateAll() if the designated constraints aren't met.
type ScanPrevMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScanPrevMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScanPrevMultiError) AllErrors() []error { return m }

// ScanPrevValidationError is the validation error returned by
// ScanPrev.Validate if the designated constraints aren't met.
type ScanPrevValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScanPrevValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScanPrevValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScanPrevValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScanPrevValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScanPrevValidationError) ErrorName() string { return "ScanPrevValidationError" }

// Error satisfies the builtin error interface
func (e ScanPrevValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScanPrev.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScanPrevValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScanPrevValidationError{}

// Validate checks the field values on ScanNext with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScanNext) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScanNext with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScanNextMultiError, or nil
// if none found.
func (m *ScanNext) ValidateAll() error {
	return m.validate(true)
}

func (m *ScanNext) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ScanNextMultiError(errors)
	}

	return nil
}

// ScanNextMultiError is an error wrapping multiple validation errors returned
// by ScanNext.ValidateAll() if the designated constraints aren't met.
type ScanNextMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScanNextMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScanNextMultiError) AllErrors() []error { return m }

// ScanNextValidationError is the validation error returned by
// ScanNext.Validate if the designated constraints aren't met.
type ScanNextValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScanNextValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScanNextValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScanNextValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScanNextValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScanNextValidationError) ErrorName() string { return "ScanNextValidationError" }

// Error satisfies the builtin error interface
func (e ScanNextValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScanNext.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScanNextValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScanNextValidationError{}

// Validate checks the field values on ScanRefreshNodeList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ScanRefreshNodeList) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScanRefreshNodeList with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ScanRefreshNodeListMultiError, or nil if none found.
func (m *ScanRefreshNodeList) ValidateAll() error {
	return m.validate(true)
}

func (m *ScanRefreshNodeList) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ScanRefreshNodeListMultiError(errors)
	}

	return nil
}

// ScanRefreshNodeListMultiError is an error wrapping multiple validation
// errors returned by ScanRefreshNodeList.ValidateAll() if the designated
// constraints aren't met.
type ScanRefreshNodeListMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScanRefreshNodeListMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScanRefreshNodeListMultiError) AllErrors() []error { return m }

// ScanRefreshNodeListValidationError is the validation error returned by
// ScanRefreshNodeList.Validate if the designated constraints aren't met.
type ScanRefreshNodeListValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScanRefreshNodeListValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScanRefreshNodeListValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScanRefreshNodeListValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScanRefreshNodeListValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScanRefreshNodeListValidationError) ErrorName() string {
	return "ScanRefreshNodeListValidationError"
}

// Error satisfies the builtin error interface
func (e ScanRefreshNodeListValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScanRefreshNodeList.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScanRefreshNodeListValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScanRefreshNodeListValidationError{}

// Validate checks the field values on ScanSelectNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScanSelectNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScanSelectNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScanSelectNodeMultiError,
// or nil if none found.
func (m *ScanSelectNode) ValidateAll() error {
	return m.validate(true)
}

func (m *ScanSelectNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	if len(errors) > 0 {
		return ScanSelectNodeMultiError(errors)
	}

	return nil
}

// ScanSelectNodeMultiError is an error wrapping multiple validation errors
// returned by ScanSelectNode.ValidateAll() if the designated constraints
// aren't met.
type ScanSelectNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScanSelectNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScanSelectNodeMultiError) AllErrors() []error { return m }

// ScanSelectNodeValidationError is the validation error returned by
// ScanSelectNode.Validate if the designated constraints aren't met.
type ScanSelectNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScanSelectNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScanSelectNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScanSelectNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScanSelectNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScanSelectNodeValidationError) ErrorName() string { return "ScanSelectNodeValidationError" }

// Error satisfies the builtin error interface
func (e ScanSelectNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScanSelectNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScanSelectNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScanSelectNodeValidationError{}

// Validate checks the field values on ScanDeleteNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScanDeleteNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScanDeleteNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScanDeleteNodeMultiError,
// or nil if none found.
func (m *ScanDeleteNode) ValidateAll() error {
	return m.validate(true)
}

func (m *ScanDeleteNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	if len(errors) > 0 {
		return ScanDeleteNodeMultiError(errors)
	}

	return nil
}

// ScanDeleteNodeMultiError is an error wrapping multiple validation errors
// returned by ScanDeleteNode.ValidateAll() if the designated constraints
// aren't met.
type ScanDeleteNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScanDeleteNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScanDeleteNodeMultiError) AllErrors() []error { return m }

// ScanDeleteNodeValidationError is the validation error returned by
// ScanDeleteNode.Validate if the designated constraints aren't met.
type ScanDeleteNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScanDeleteNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScanDeleteNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScanDeleteNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScanDeleteNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScanDeleteNodeValidationError) ErrorName() string { return "ScanDeleteNodeValidationError" }

// Error satisfies the builtin error interface
func (e ScanDeleteNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScanDeleteNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScanDeleteNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScanDeleteNodeValidationError{}

// Validate checks the field values on ScanUpdateNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScanUpdateNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScanUpdateNode with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScanUpdateNodeMultiError,
// or nil if none found.
func (m *ScanUpdateNode) ValidateAll() error {
	return m.validate(true)
}

func (m *ScanUpdateNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	// no validation rules for DayZoomTableValue

	// no validation rules for HeatZoomTableValue

	// no validation rules for Azimuth

	// no validation rules for Elevation

	// no validation rules for Linger

	// no validation rules for Speed

	if len(errors) > 0 {
		return ScanUpdateNodeMultiError(errors)
	}

	return nil
}

// ScanUpdateNodeMultiError is an error wrapping multiple validation errors
// returned by ScanUpdateNode.ValidateAll() if the designated constraints
// aren't met.
type ScanUpdateNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScanUpdateNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScanUpdateNodeMultiError) AllErrors() []error { return m }

// ScanUpdateNodeValidationError is the validation error returned by
// ScanUpdateNode.Validate if the designated constraints aren't met.
type ScanUpdateNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScanUpdateNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScanUpdateNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScanUpdateNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScanUpdateNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScanUpdateNodeValidationError) ErrorName() string { return "ScanUpdateNodeValidationError" }

// Error satisfies the builtin error interface
func (e ScanUpdateNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScanUpdateNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScanUpdateNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScanUpdateNodeValidationError{}

// Validate checks the field values on ScanAddNode with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ScanAddNode) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ScanAddNode with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ScanAddNodeMultiError, or
// nil if none found.
func (m *ScanAddNode) ValidateAll() error {
	return m.validate(true)
}

func (m *ScanAddNode) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Index

	// no validation rules for DayZoomTableValue

	// no validation rules for HeatZoomTableValue

	// no validation rules for Azimuth

	// no validation rules for Elevation

	// no validation rules for Linger

	// no validation rules for Speed

	if len(errors) > 0 {
		return ScanAddNodeMultiError(errors)
	}

	return nil
}

// ScanAddNodeMultiError is an error wrapping multiple validation errors
// returned by ScanAddNode.ValidateAll() if the designated constraints aren't met.
type ScanAddNodeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ScanAddNodeMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ScanAddNodeMultiError) AllErrors() []error { return m }

// ScanAddNodeValidationError is the validation error returned by
// ScanAddNode.Validate if the designated constraints aren't met.
type ScanAddNodeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ScanAddNodeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ScanAddNodeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ScanAddNodeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ScanAddNodeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ScanAddNodeValidationError) ErrorName() string { return "ScanAddNodeValidationError" }

// Error satisfies the builtin error interface
func (e ScanAddNodeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sScanAddNode.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ScanAddNodeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ScanAddNodeValidationError{}

// Validate checks the field values on Elevation with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Elevation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Elevation with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ElevationMultiError, or nil
// if none found.
func (m *Elevation) ValidateAll() error {
	return m.validate(true)
}

func (m *Elevation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Cmd.(type) {
	case *Elevation_SetValue:
		if v == nil {
			err := ElevationValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetSetValue()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ElevationValidationError{
						field:  "SetValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ElevationValidationError{
						field:  "SetValue",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetSetValue()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ElevationValidationError{
					field:  "SetValue",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Elevation_RotateTo:
		if v == nil {
			err := ElevationValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRotateTo()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ElevationValidationError{
						field:  "RotateTo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ElevationValidationError{
						field:  "RotateTo",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRotateTo()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ElevationValidationError{
					field:  "RotateTo",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Elevation_Rotate:
		if v == nil {
			err := ElevationValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRotate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ElevationValidationError{
						field:  "Rotate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ElevationValidationError{
						field:  "Rotate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRotate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ElevationValidationError{
					field:  "Rotate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Elevation_Relative:
		if v == nil {
			err := ElevationValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRelative()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ElevationValidationError{
						field:  "Relative",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ElevationValidationError{
						field:  "Relative",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRelative()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ElevationValidationError{
					field:  "Relative",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Elevation_RelativeSet:
		if v == nil {
			err := ElevationValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetRelativeSet()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ElevationValidationError{
						field:  "RelativeSet",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ElevationValidationError{
						field:  "RelativeSet",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetRelativeSet()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ElevationValidationError{
					field:  "RelativeSet",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	case *Elevation_Halt:
		if v == nil {
			err := ElevationValidationError{
				field:  "Cmd",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetHalt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ElevationValidationError{
						field:  "Halt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ElevationValidationError{
						field:  "Halt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetHalt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ElevationValidationError{
					field:  "Halt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if len(errors) > 0 {
		return ElevationMultiError(errors)
	}

	return nil
}

// ElevationMultiError is an error wrapping multiple validation errors returned
// by Elevation.ValidateAll() if the designated constraints aren't met.
type ElevationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ElevationMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ElevationMultiError) AllErrors() []error { return m }

// ElevationValidationError is the validation error returned by
// Elevation.Validate if the designated constraints aren't met.
type ElevationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ElevationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ElevationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ElevationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ElevationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ElevationValidationError) ErrorName() string { return "ElevationValidationError" }

// Error satisfies the builtin error interface
func (e ElevationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sElevation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ElevationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ElevationValidationError{}

// Validate checks the field values on SetUseRotaryAsCompass with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SetUseRotaryAsCompass) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetUseRotaryAsCompass with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SetUseRotaryAsCompassMultiError, or nil if none found.
func (m *SetUseRotaryAsCompass) ValidateAll() error {
	return m.validate(true)
}

func (m *SetUseRotaryAsCompass) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Flag

	if len(errors) > 0 {
		return SetUseRotaryAsCompassMultiError(errors)
	}

	return nil
}

// SetUseRotaryAsCompassMultiError is an error wrapping multiple validation
// errors returned by SetUseRotaryAsCompass.ValidateAll() if the designated
// constraints aren't met.
type SetUseRotaryAsCompassMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetUseRotaryAsCompassMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetUseRotaryAsCompassMultiError) AllErrors() []error { return m }

// SetUseRotaryAsCompassValidationError is the validation error returned by
// SetUseRotaryAsCompass.Validate if the designated constraints aren't met.
type SetUseRotaryAsCompassValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetUseRotaryAsCompassValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetUseRotaryAsCompassValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetUseRotaryAsCompassValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetUseRotaryAsCompassValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetUseRotaryAsCompassValidationError) ErrorName() string {
	return "SetUseRotaryAsCompassValidationError"
}

// Error satisfies the builtin error interface
func (e SetUseRotaryAsCompassValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetUseRotaryAsCompass.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetUseRotaryAsCompassValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetUseRotaryAsCompassValidationError{}

// Validate checks the field values on RotateToGPS with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RotateToGPS) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RotateToGPS with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RotateToGPSMultiError, or
// nil if none found.
func (m *RotateToGPS) ValidateAll() error {
	return m.validate(true)
}

func (m *RotateToGPS) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Latitude

	// no validation rules for Longitude

	// no validation rules for Altitude

	if len(errors) > 0 {
		return RotateToGPSMultiError(errors)
	}

	return nil
}

// RotateToGPSMultiError is an error wrapping multiple validation errors
// returned by RotateToGPS.ValidateAll() if the designated constraints aren't met.
type RotateToGPSMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RotateToGPSMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RotateToGPSMultiError) AllErrors() []error { return m }

// RotateToGPSValidationError is the validation error returned by
// RotateToGPS.Validate if the designated constraints aren't met.
type RotateToGPSValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RotateToGPSValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RotateToGPSValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RotateToGPSValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RotateToGPSValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RotateToGPSValidationError) ErrorName() string { return "RotateToGPSValidationError" }

// Error satisfies the builtin error interface
func (e RotateToGPSValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRotateToGPS.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RotateToGPSValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RotateToGPSValidationError{}

// Validate checks the field values on SetOriginGPS with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SetOriginGPS) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SetOriginGPS with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SetOriginGPSMultiError, or
// nil if none found.
func (m *SetOriginGPS) ValidateAll() error {
	return m.validate(true)
}

func (m *SetOriginGPS) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Latitude

	// no validation rules for Longitude

	// no validation rules for Altitude

	if len(errors) > 0 {
		return SetOriginGPSMultiError(errors)
	}

	return nil
}

// SetOriginGPSMultiError is an error wrapping multiple validation errors
// returned by SetOriginGPS.ValidateAll() if the designated constraints aren't met.
type SetOriginGPSMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetOriginGPSMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetOriginGPSMultiError) AllErrors() []error { return m }

// SetOriginGPSValidationError is the validation error returned by
// SetOriginGPS.Validate if the designated constraints aren't met.
type SetOriginGPSValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetOriginGPSValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetOriginGPSValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetOriginGPSValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetOriginGPSValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetOriginGPSValidationError) ErrorName() string { return "SetOriginGPSValidationError" }

// Error satisfies the builtin error interface
func (e SetOriginGPSValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetOriginGPS.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetOriginGPSValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetOriginGPSValidationError{}

// Validate checks the field values on RotateToNDC with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RotateToNDC) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RotateToNDC with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RotateToNDCMultiError, or
// nil if none found.
func (m *RotateToNDC) ValidateAll() error {
	return m.validate(true)
}

func (m *RotateToNDC) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Channel

	// no validation rules for X

	// no validation rules for Y

	if len(errors) > 0 {
		return RotateToNDCMultiError(errors)
	}

	return nil
}

// RotateToNDCMultiError is an error wrapping multiple validation errors
// returned by RotateToNDC.ValidateAll() if the designated constraints aren't met.
type RotateToNDCMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RotateToNDCMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RotateToNDCMultiError) AllErrors() []error { return m }

// RotateToNDCValidationError is the validation error returned by
// RotateToNDC.Validate if the designated constraints aren't met.
type RotateToNDCValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RotateToNDCValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RotateToNDCValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RotateToNDCValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RotateToNDCValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RotateToNDCValidationError) ErrorName() string { return "RotateToNDCValidationError" }

// Error satisfies the builtin error interface
func (e RotateToNDCValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRotateToNDC.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RotateToNDCValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RotateToNDCValidationError{}
